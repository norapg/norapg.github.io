<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Variations on a Scheme -- Nondeterministic Computing - SICP</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./src/styles/docco.min.css">
        <link rel="stylesheet" href="./run_button_style.css">
        <link rel="stylesheet" href="./custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SICP</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="43--variations-on-a-scheme----nondeterministic-computing"><a class="header" href="#43--variations-on-a-scheme----nondeterministic-computing"><a href="book-Z-H-4.html#%_toc_%_sec_4.3">4.3  Variations on a Scheme -- Nondeterministic Computing</a></a></h2>
<p>In this section, we extend the Scheme
evaluator to support a programming paradigm called <em>nondeterministic
computing</em> by building into the evaluator a facility to support
automatic search. This is a much more profound change to the language
than the introduction of lazy evaluation in
section <a href="book-Z-H-27.html#%_sec_4.2">4.2</a>.</p>
<p>Nondeterministic computing, like stream processing, is
useful for ''generate and test'' applications. Consider the task of
starting with two lists of positive integers and finding a pair of
integers -- one from the first list and one from the second list --
whose sum is prime. We saw how to handle this with finite sequence
operations in section <a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a> and with
infinite streams in section <a href="book-Z-H-24.html#%_sec_3.5.3">3.5.3</a>. Our
approach was to generate the sequence of all possible pairs and filter
these to select the pairs whose sum is prime. Whether we actually
generate the entire sequence of pairs first as in chapter 2, or
interleave the generating and filtering as in chapter 3, is immaterial
to the essential image of how the computation is organized.</p>
<p>The nondeterministic approach evokes a different image.
Imagine simply that we choose (in some way) a number from the first list
and a number from the second list and require (using some mechanism)
that their sum be prime. This is expressed by following procedure:</p>
<pre><code class="language-scheme editable">(define (prime-sum-pair list1 list2)
  (let ((a (an-element-of list1))
        (b (an-element-of list2)))
    (require (prime? (+ a b)))
    (list a b)))
</code></pre>
<p>It might seem as if this procedure merely restates the problem, rather
than specifying a way to solve it. Nevertheless, this is a legitimate
nondeterministic
program.<a href="book-Z-H-28.html#footnote_Temp_598">^[42]{.small}^</a></p>
<p>The key idea here is that expressions in a nondeterministic language can
have more than one possible value. For instance, <code>an-element-of</code> might
return any element of the given list. Our nondeterministic program
evaluator will work by automatically choosing a possible value and
keeping track of the choice. If a subsequent requirement is not met, the
evaluator will try a different choice, and it will keep trying new
choices until the evaluation succeeds, or until we run out of choices.
Just as the lazy evaluator freed the programmer from the details of how
values are delayed and forced, the nondeterministic program evaluator
will free the programmer from the details of how choices are made.</p>
<p>It is instructive to contrast the different images of
time evoked by nondeterministic evaluation and stream processing. Stream
processing uses lazy evaluation to decouple the time when the stream of
possible answers is assembled from the time when the actual stream
elements are produced. The evaluator supports the illusion that all the
possible answers are laid out before us in a timeless sequence. With
nondeterministic evaluation, an expression represents the exploration of
a set of possible worlds, each determined by a set of choices. Some of
the possible worlds lead to dead ends, while others have useful values.
The nondeterministic program evaluator supports the illusion that time
branches, and that our programs have different possible execution
histories. When we reach a dead end, we can revisit a previous choice
point and proceed along a different branch.</p>
<p>The nondeterministic program evaluator implemented below is called the
<code>amb</code> evaluator because it is based on a new special form called <code>amb</code>.
We can type the above definition of <code>prime-sum-pair</code> at the <code>amb</code>
evaluator driver loop (along with definitions of <code>prime?</code>,
<code>an-element-of</code>, and <code>require</code>) and run the procedure as follows:</p>
<p><em><code>;;; Amb-Eval input:</code></em></p>
<pre><code class="language-scheme editable">(prime-sum-pair '(1 3 5 8) '(20 35 110))
</code></pre>
<p><em><code>;;; Starting a new problem</code></em>
<em><code>;;; Amb-Eval value:</code></em>
<em><code>(3 20)</code></em></p>
<p>The value returned was obtained after the evaluator repeatedly chose
elements from each of the lists, until a successful choice was made.</p>
<p>Section <a href="book-Z-H-28.html#%_sec_4.3.1">4.3.1</a> introduces <code>amb</code> and
explains how it supports nondeterminism through the evaluator's
automatic search mechanism. Section
<a href="book-Z-H-28.html#%_sec_4.3.2">4.3.2</a> presents examples of
nondeterministic programs, and
section <a href="book-Z-H-28.html#%_sec_4.3.3">4.3.3</a> gives the details of how
to implement the <code>amb</code> evaluator by modifying the ordinary Scheme
evaluator.</p>
<h3 id="431--amb-and-search"><a class="header" href="#431--amb-and-search"><a href="book-Z-H-4.html#%_toc_%_sec_4.3.1">4.3.1  Amb and Search</a></a></h3>
<p>To extend Scheme to support nondeterminism, we introduce
a new special form called
<code>amb</code>.<a href="book-Z-H-28.html#footnote_Temp_599">^[43]{.small}^</a>
The expression
<code>(amb &lt;</code><strong><code>e</code><em><del><code>1</code></del></em><code>&gt; &lt;</code></strong><code>e</code><em><del><code>2</code></del></em><code>&gt; ... &lt;</code>**<code>e</code><em>~</em><code>n</code><em>~</em><code>&gt;)</code>
returns the value of one of the <em>n</em> expressions &lt;*<em>e</em><del><em>i</em></del>*&gt;
''ambiguously.'' For example, the expression</p>
<pre><code class="language-scheme editable">(list (amb 1 2 3) (amb 'a 'b))
</code></pre>
<p>can have six possible values:</p>
<hr />
<p><code>(1 a) </code>   <code>(1 b) </code>   <code>(2 a) </code>   <code>(2 b) </code>   <code>(3 a) </code>   <code>(3 b) </code></p>
<hr />
<p><code>Amb</code> with a single choice produces an ordinary (single) value.</p>
<p><code>Amb</code> with no choices -- the expression <code>(amb)</code> -- is
an expression with no acceptable values. Operationally, we can think of
<code>(amb)</code> as an expression that when evaluated causes the computation to
''fail'': The computation aborts and no value is produced. Using
this idea, we can express the requirement that a particular predicate
expression <code>p</code> must be true as follows:</p>
<pre><code class="language-scheme editable">(define (require p)
  (if (not p) (amb)))
</code></pre>
<p>With <code>amb</code> and <code>require</code>, we can implement the <code>an-element-of</code> procedure
used above:</p>
<pre><code class="language-scheme editable">(define (an-element-of items)
  (require (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))
</code></pre>
<p><code>An-element-of</code> fails if the list is empty. Otherwise it ambiguously
returns either the first element of the list or an element chosen from
the rest of the list.</p>
<p>We can also express infinite ranges of choices. The following procedure
potentially returns any integer greater than or equal to some given <em>n</em>:</p>
<pre><code class="language-scheme editable">(define (an-integer-starting-from n)
  (amb n (an-integer-starting-from (+ n 1))))
</code></pre>
<p>This is like the stream procedure <code>integers-starting-from</code> described in
section <a href="book-Z-H-24.html#%_sec_3.5.2">3.5.2</a>, but with an important
difference: The stream procedure returns an object that represents the
sequence of all integers beginning with <em>n</em>, whereas the <code>amb</code> procedure
returns a single
integer.<a href="book-Z-H-28.html#footnote_Temp_600">^[44]{.small}^</a></p>
<p>Abstractly, we can imagine that evaluating an <code>amb</code>
expression causes time to split into branches, where the computation
continues on each branch with one of the possible values of the
expression. We say that <code>amb</code> represents a
<em>nondeterministic choice point</em>. If we had a machine with
a sufficient number of processors that could be dynamically allocated,
we could implement the search in a straightforward way. Execution would
proceed as in a sequential machine, until an <code>amb</code> expression is
encountered. At this point, more processors would be allocated and
initialized to continue all of the parallel executions implied by the
choice. Each processor would proceed sequentially as if it were the only
choice, until it either terminates by encountering a failure, or it
further subdivides, or it
finishes.<a href="book-Z-H-28.html#footnote_Temp_601">^[45]{.small}^</a></p>
<p>On the other hand, if we have a machine that can execute
only one process (or a few concurrent processes), we must consider the
alternatives sequentially. One could imagine modifying an evaluator to
pick at random a branch to follow whenever it encounters a choice point.
Random choice, however, can easily lead to failing values. We might try
running the evaluator over and over, making random choices and hoping to
find a non-failing value, but it is better to
<em>systematically search</em> all possible
execution paths. The <code>amb</code> evaluator that we will develop and work with
in this section implements a systematic search as follows: When the
evaluator encounters an application of <code>amb</code>, it initially selects the
first alternative. This selection may itself lead to a further choice.
The evaluator will always initially choose the first alternative at each
choice point. If a choice results in a failure, then the evaluator
automagically<a href="book-Z-H-28.html#footnote_Temp_602">^[46]{.small}^</a>
<em>backtracks</em> to the most recent choice point and tries
the next alternative. If it runs out of alternatives at any choice
point, the evaluator will back up to the previous choice point and
resume from there. This process leads to a search strategy known as
<em>depth-first search</em> or
<em>chronological
backtracking</em>.<a href="book-Z-H-28.html#footnote_Temp_603">^[47]{.small}^</a></p>
<h4 id="driver-loop"><a class="header" href="#driver-loop"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_604">Driver loop</a></a></h4>
<p>The driver loop for the <code>amb</code> evaluator has some unusual
properties. It reads an expression and prints the value of the first
non-failing execution, as in the <code>prime-sum-pair</code> example shown above.
If we want to see the value of the next successful execution, we can ask
the interpreter to backtrack and attempt to generate a second
non-failing execution. This is signaled by typing the symbol
<code>try-again</code>. If any expression except <code>try-again</code> is
given, the interpreter will start a new problem, discarding the
unexplored alternatives in the previous problem. Here is a sample
interaction:</p>
<p><em><code>;;; Amb-Eval input:</code></em></p>
<pre><code class="language-scheme editable">(prime-sum-pair '(1 3 5 8) '(20 35 110))
</code></pre>
<p><em><code>;;; Starting a new problem</code></em>
<em><code>;;; Amb-Eval value:</code></em>
<em><code>(3 20)</code></em>
<em><code>;;; Amb-Eval input:</code></em></p>
<pre><code class="language-scheme editable">try-again
</code></pre>
<p><em><code>;;; Amb-Eval value:</code></em>
<em><code>(3 110)</code></em>
<em><code>;;; Amb-Eval input:</code></em></p>
<pre><code class="language-scheme editable">try-again
</code></pre>
<p><em><code>;;; Amb-Eval value:</code></em>
<em><code>(8 35)</code></em>
<em><code>;;; Amb-Eval input:</code></em></p>
<pre><code class="language-scheme editable">try-again
</code></pre>
<p><em><code>;;; There are no more values of</code></em>
<em><code>(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))</code></em>
<em><code>;;; Amb-Eval input:</code></em></p>
<pre><code class="language-scheme editable">(prime-sum-pair '(19 27 30) '(11 36 58))
</code></pre>
<p><em><code>;;; Starting a new problem</code></em>
<em><code>;;; Amb-Eval value:</code></em>
<em><code>(30 11)</code></em></p>
<p><strong>Exercise 4.35.</strong>  Write
a procedure <code>an-integer-between</code> that returns an integer between two
given bounds. This can be used to implement a procedure that finds
Pythagorean triples, i.e., triples of integers (<em>i</em>,<em>j</em>,<em>k</em>) between the
given bounds such that <em>i</em> [&lt;]{.underline} <em>j</em> and <em>i</em>^2^ + <em>j</em>^2^ =
<em>k</em>^2^, as follows:</p>
<pre><code class="language-scheme editable">(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high)))
    (let ((j (an-integer-between i high)))
      (let ((k (an-integer-between j high)))
        (require (= (+ (* i i) (* j j)) (* k k)))
        (list i j k)))))
</code></pre>
<p><strong>Exercise
4.36.</strong>  Exercise <a href="book-Z-H-24.html#%_thm_3.69">3.69</a>
discussed how to generate the stream of <em>all</em> Pythagorean triples, with
no upper bound on the size of the integers to be searched. Explain why
simply replacing <code>an-integer-between</code> by <code>an-integer-starting-from</code> in
the procedure in exercise <a href="book-Z-H-28.html#%_thm_4.35">4.35</a> is not an
adequate way to generate arbitrary Pythagorean triples. Write a
procedure that actually will accomplish this. (That is, write a
procedure for which repeatedly typing <code>try-again</code> would in principle
eventually generate all Pythagorean triples.)</p>
<p><strong>Exercise 4.37.</strong>  Ben
Bitdiddle claims that the following method for generating Pythagorean
triples is more efficient than the one in
exercise <a href="book-Z-H-28.html#%_thm_4.35">4.35</a>. Is he correct? (Hint:
Consider the number of possibilities that must be explored.)</p>
<pre><code class="language-scheme editable">(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high))
        (hsq (* high high)))
    (let ((j (an-integer-between i high)))
      (let ((ksq (+ (* i i) (* j j))))
        (require (&gt;= hsq ksq))
        (let ((k (sqrt ksq)))
          (require (integer? k))
          (list i j k))))))
</code></pre>
<h3 id="432--examples-of-nondeterministic-programs"><a class="header" href="#432--examples-of-nondeterministic-programs"><a href="book-Z-H-4.html#%_toc_%_sec_4.3.2">4.3.2  Examples of Nondeterministic Programs</a></a></h3>
<p>Section <a href="book-Z-H-28.html#%_sec_4.3.3">4.3.3</a> describes the
implementation of the <code>amb</code> evaluator. First, however, we give some
examples of how it can be used. The advantage of nondeterministic
programming is that we can suppress the details of how search is carried
out, thereby expressing our programs at a higher level of
abstraction.</p>
<h4 id="logic-puzzles"><a class="header" href="#logic-puzzles"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_608">Logic Puzzles</a></a></h4>
<p>The
following puzzle (taken from Dinesman 1968) is typical of a large class
of simple logic puzzles:</p>
<blockquote>
<p>Baker, Cooper, Fletcher, Miller, and Smith live on different floors of
an apartment house that contains only five floors. Baker does not live
on the top floor. Cooper does not live on the bottom floor. Fletcher
does not live on either the top or the bottom floor. Miller lives on a
higher floor than does Cooper. Smith does not live on a floor adjacent
to Fletcher's. Fletcher does not live on a floor adjacent to
Cooper's. Where does everyone live?</p>
</blockquote>
<p>We can determine who lives on each floor in a straightforward way by
enumerating all the possibilities and imposing the given
restrictions:<a href="book-Z-H-28.html#footnote_Temp_609">^[48]{.small}^</a></p>
<pre><code class="language-scheme editable">(define (multiple-dwelling)
  (let ((baker (amb 1 2 3 4 5))
        (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5))
        (miller (amb 1 2 3 4 5))
        (smith (amb 1 2 3 4 5)))
    (require
     (distinct? (list baker cooper fletcher miller smith)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (&gt; miller cooper))
    (require (not (= (abs (- smith fletcher)) 1)))
    (require (not (= (abs (- fletcher cooper)) 1)))
    (list (list 'baker baker)
          (list 'cooper cooper)
          (list 'fletcher fletcher)
          (list 'miller miller)
          (list 'smith smith))))
</code></pre>
<p>Evaluating the expression <code>(multiple-dwelling)</code> produces the result</p>
<p><code>((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))</code></p>
<p>Although this simple procedure works, it is very slow.
Exercises <a href="book-Z-H-28.html#%_thm_4.39">4.39</a>
and <a href="book-Z-H-28.html#%_thm_4.40">4.40</a> discuss some possible
improvements.</p>
<p><strong>Exercise 4.38.</strong>  Modify the multiple-dwelling
procedure to omit the requirement that Smith and Fletcher do not live on
adjacent floors. How many solutions are there to this modified puzzle?</p>
<p><strong>Exercise 4.39.</strong>  Does the order of the restrictions
in the multiple-dwelling procedure affect the answer? Does it affect the
time to find an answer? If you think it matters, demonstrate a faster
program obtained from the given one by reordering the restrictions. If
you think it does not matter, argue your case.</p>
<p><strong>Exercise 4.40.</strong>  In the multiple dwelling problem,
how many sets of assignments are there of people to floors, both before
and after the requirement that floor assignments be distinct? It is very
inefficient to generate all possible assignments of people to floors and
then leave it to backtracking to eliminate them. For example, most of
the restrictions depend on only one or two of the person-floor
variables, and can thus be imposed before floors have been selected for
all the people. Write and demonstrate a much more efficient
nondeterministic procedure that solves this problem based upon
generating only those possibilities that are not already ruled out by
previous restrictions. (Hint: This will require a nest of <code>let</code>
expressions.)</p>
<p><strong>Exercise 4.41.</strong>  Write an ordinary
Scheme program to solve the multiple dwelling puzzle.</p>
<p><strong>Exercise 4.42.</strong>  Solve the following
''Liars'' puzzle (from Phillips 1934):</p>
<blockquote>
<p>Five schoolgirls sat for an examination. Their parents -- so they
thought -- showed an undue degree of interest in the result. They
therefore agreed that, in writing home about the examination, each
girl should make one true statement and one untrue one. The following
are the relevant passages from their letters:</p>
<ul>
<li>Betty: ''Kitty was second in the examination. I was only
third.''</li>
<li>Ethel: ''You'll be glad to hear that I was on top. Joan was
second.''</li>
<li>Joan: ''I was third, and poor old Ethel was bottom.''</li>
<li>Kitty: ''I came out second. Mary was only fourth.''</li>
<li>Mary: ''I was fourth. Top place was taken by Betty.''</li>
</ul>
<p>What in fact was the order in which the five girls were placed?</p>
</blockquote>
<p><strong>Exercise 4.43.</strong>  Use the <code>amb</code> evaluator to solve the
following
puzzle:<a href="book-Z-H-28.html#footnote_Temp_616">^[49]{.small}^</a></p>
<blockquote>
<p>Mary Ann Moore's father has a yacht and so has each of his four
friends: Colonel Downing, Mr. Hall, Sir Barnacle Hood, and Dr. Parker.
Each of the five also has one daughter and each has named his yacht
after a daughter of one of the others. Sir Barnacle's yacht is the
Gabrielle, Mr. Moore owns the Lorna; Mr. Hall the Rosalind. The
Melissa, owned by Colonel Downing, is named after Sir Barnacle's
daughter. Gabrielle's father owns the yacht that is named after Dr.
Parker's daughter. Who is Lorna's father?</p>
</blockquote>
<p>Try to write the program so that it runs efficiently (see
exercise <a href="book-Z-H-28.html#%_thm_4.40">4.40</a>). Also determine how many
solutions there are if we are not told that Mary Ann's last name is
Moore.</p>
<p><strong>Exercise
4.44.</strong>  Exercise <a href="book-Z-H-15.html#%_thm_2.42">2.42</a>
described the ''eight-queens puzzle'' of placing queens on a
chessboard so that no two attack each other. Write a nondeterministic
program to solve this puzzle.</p>
<h4 id="parsing-natural-language"><a class="header" href="#parsing-natural-language"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_618">Parsing natural language</a></a></h4>
<p>Programs designed to accept natural
language as input usually start by attempting to <em>parse</em> the input, that
is, to match the input against some grammatical structure. For example,
we might try to recognize simple sentences consisting of an article
followed by a noun followed by a verb, such as ''The cat eats.'' To
accomplish such an analysis, we must be able to identify the parts of
speech of individual words. We could start with some lists that classify
various
words:<a href="book-Z-H-28.html#footnote_Temp_619">^[50]{.small}^</a></p>
<pre><code class="language-scheme editable">(define nouns '(noun student professor cat class))
(define verbs '(verb studies lectures eats sleeps))
(define articles '(article the a))
</code></pre>
<p>We also need a <em>grammar</em>, that is, a set of rules
describing how grammatical elements are composed from simpler elements.
A very simple grammar might stipulate that a sentence always consists of
two pieces -- a noun phrase followed by a verb -- and that a noun
phrase consists of an article followed by a noun. With this grammar, the
sentence ''The cat eats'' is parsed as follows:</p>
<p><code>(sentence (noun-phrase (article the) (noun cat))</code>
<code>          (verb eats))</code></p>
<p>We can generate such a parse with a simple program that has separate
procedures for each of the grammatical rules. To parse a sentence, we
identify its two constituent pieces and return a list of these two
elements, tagged with the symbol <code>sentence</code>:</p>
<pre><code class="language-scheme editable">(define (parse-sentence)
  (list 'sentence
        (parse-noun-phrase)
        (parse-word verbs)))
</code></pre>
<p>A noun phrase, similarly, is parsed by finding an article followed by a
noun:</p>
<pre><code class="language-scheme editable">(define (parse-noun-phrase)
  (list 'noun-phrase
        (parse-word articles)
        (parse-word nouns)))
</code></pre>
<p>At the lowest level, parsing boils down to repeatedly checking that the
next unparsed word is a member of the list of words for the required
part of speech. To implement this, we maintain a global variable
<code>*unparsed*</code>, which is the input that has not yet been parsed. Each time
we check a word, we require that <code>*unparsed*</code> must be non-empty and that
it should begin with a word from the designated list. If so, we remove
that word from <code>*unparsed*</code> and return the word together with its part
of speech (which is found at the head of the
list):<a href="book-Z-H-28.html#footnote_Temp_620">^[51]{.small}^</a></p>
<pre><code class="language-scheme editable">(define (parse-word word-list)
  (require (not (null? *unparsed*)))
  (require (memq (car *unparsed*) (cdr word-list)))
  (let ((found-word (car *unparsed*)))
    (set! *unparsed* (cdr *unparsed*))
    (list (car word-list) found-word)))
</code></pre>
<p>To start the parsing, all we need to do is set <code>*unparsed*</code> to be the
entire input, try to parse a sentence, and check that nothing is left
over:</p>
<pre><code class="language-scheme editable">(define *unparsed* '())
(define (parse input)
  (set! *unparsed* input)
  (let ((sent (parse-sentence)))
    (require (null? *unparsed*))
    sent))
</code></pre>
<p>We can now try the parser and verify that it works for our simple test
sentence:</p>
<p><em><code>;;; Amb-Eval input:</code></em></p>
<pre><code class="language-scheme editable">(parse '(the cat eats))
</code></pre>
<p><em><code>;;; Starting a new problem</code></em>
<em><code>;;; Amb-Eval value:</code></em>
<em><code>(sentence (noun-phrase (article the) (noun cat)) (verb eats))</code></em></p>
<p>The <code>amb</code> evaluator is useful here because it is convenient to express
the parsing constraints with the aid of <code>require</code>. Automatic search and
backtracking really pay off, however, when we consider more complex
grammars where there are choices for how the units can be decomposed.</p>
<p>Let's add to our grammar a list of prepositions:</p>
<pre><code class="language-scheme editable">(define prepositions '(prep for to in by with))
</code></pre>
<p>and define a prepositional phrase (e.g., ''for the cat'') to be a
preposition followed by a noun phrase:</p>
<pre><code class="language-scheme editable">(define (parse-prepositional-phrase)
  (list 'prep-phrase
        (parse-word prepositions)
        (parse-noun-phrase)))
</code></pre>
<p>Now we can define a sentence to be a noun phrase followed by a verb
phrase, where a verb phrase can be either a verb or a verb phrase
extended by a prepositional
phrase:<a href="book-Z-H-28.html#footnote_Temp_621">^[52]{.small}^</a></p>
<pre><code class="language-scheme editable">(define (parse-sentence)
  (list 'sentence
        (parse-noun-phrase)
        (parse-verb-phrase)))
(define (parse-verb-phrase)
  (define (maybe-extend verb-phrase)
    (amb verb-phrase
         (maybe-extend (list 'verb-phrase
                             verb-phrase
                             (parse-prepositional-phrase)))))
  (maybe-extend (parse-word verbs)))
</code></pre>
<p>While we're at it, we can also elaborate the definition of noun phrases
to permit such things as ''a cat in the class.'' What we used to
call a noun phrase, we'll now call a simple noun phrase, and a noun
phrase will now be either a simple noun phrase or a noun phrase extended
by a prepositional phrase:</p>
<pre><code class="language-scheme editable">(define (parse-simple-noun-phrase)
  (list 'simple-noun-phrase
        (parse-word articles)
        (parse-word nouns)))
(define (parse-noun-phrase)
  (define (maybe-extend noun-phrase)
    (amb noun-phrase
         (maybe-extend (list 'noun-phrase
                             noun-phrase
                             (parse-prepositional-phrase)))))
  (maybe-extend (parse-simple-noun-phrase)))
</code></pre>
<p>Our new grammar lets us parse more complex sentences. For example</p>
<pre><code class="language-scheme editable">(parse '(the student with the cat sleeps in the class))
</code></pre>
<p>produces</p>
<p><code>(sentence</code>
<code> (noun-phrase</code>
<code>  (simple-noun-phrase (article the) (noun student))</code>
<code>  (prep-phrase (prep with)</code>
<code>               (simple-noun-phrase</code>
<code>                (article the) (noun cat))))</code>
<code> (verb-phrase</code>
<code>  (verb sleeps)</code>
<code>  (prep-phrase (prep in)</code>
<code>               (simple-noun-phrase</code>
<code>                (article the) (noun class)))))</code></p>
<p>Observe that a given input may have more than one legal parse. In the
sentence ''The professor lectures to the student with the cat,'' it
may be that the professor is lecturing with the cat, or that the student
has the cat. Our nondeterministic program finds both possibilities:</p>
<pre><code class="language-scheme editable">(parse '(the professor lectures to the student with the cat))
</code></pre>
<p>produces</p>
<p><code>(sentence</code>
<code> (simple-noun-phrase (article the) (noun professor))</code>
<code> (verb-phrase</code>
<code>  (verb-phrase</code>
<code>   (verb lectures)</code>
<code>   (prep-phrase (prep to)</code>
<code>                (simple-noun-phrase</code>
<code>                 (article the) (noun student))))</code>
<code>  (prep-phrase (prep with)</code>
<code>               (simple-noun-phrase</code>
<code>                (article the) (noun cat)))))</code></p>
<p>Asking the evaluator to try again yields</p>
<p><code>(sentence</code>
<code> (simple-noun-phrase (article the) (noun professor))</code>
<code> (verb-phrase</code>
<code>  (verb lectures)</code>
<code>  (prep-phrase (prep to)</code>
<code>               (noun-phrase</code>
<code>                (simple-noun-phrase</code>
<code>                 (article the) (noun student))</code>
<code>                (prep-phrase (prep with)</code>
<code>                             (simple-noun-phrase</code>
<code>                              (article the) (noun cat)))))))</code></p>
<p><strong>Exercise 4.45.</strong>  With the grammar given above, the
following sentence can be parsed in five different ways: ''The
professor lectures to the student in the class with the cat.'' Give
the five parses and explain the differences in shades of meaning among
them.</p>
<p><strong>Exercise 4.46.</strong>  The evaluators in
sections <a href="book-Z-H-26.html#%_sec_4.1">4.1</a> and
<a href="book-Z-H-27.html#%_sec_4.2">4.2</a> do not determine what order operands
are evaluated in. We will see that the <code>amb</code> evaluator evaluates them
from left to right. Explain why our parsing program wouldn't work if
the operands were evaluated in some other order.</p>
<p><strong>Exercise 4.47.</strong>  Louis Reasoner suggests that, since
a verb phrase is either a verb or a verb phrase followed by a
prepositional phrase, it would be much more straightforward to define
the procedure <code>parse-verb-phrase</code> as follows (and similarly for noun
phrases):</p>
<pre><code class="language-scheme editable">(define (parse-verb-phrase)
  (amb (parse-word verbs)
       (list 'verb-phrase
             (parse-verb-phrase)
             (parse-prepositional-phrase))))
</code></pre>
<p>Does this work? Does the program's behavior change if we interchange
the order of expressions in the <code>amb</code>?</p>
<p><strong>Exercise 4.48.</strong>  Extend the grammar given above to
handle more complex sentences. For example, you could extend noun
phrases and verb phrases to include adjectives and adverbs, or you could
handle compound
sentences.<a href="book-Z-H-28.html#footnote_Temp_626">^[53]{.small}^</a></p>
<p><strong>Exercise 4.49.</strong>  Alyssa P. Hacker is
more interested in generating interesting sentences than in parsing
them. She reasons that by simply changing the procedure <code>parse-word</code> so
that it ignores the ''input sentence'' and instead always succeeds
and generates an appropriate word, we can use the programs we had built
for parsing to do generation instead. Implement Alyssa's idea, and show
the first half-dozen or so sentences
generated.<a href="book-Z-H-28.html#footnote_Temp_628">^[54]{.small}^</a></p>
<h3 id="433--implementing-the-amb-evaluator"><a class="header" href="#433--implementing-the-amb-evaluator"><a href="book-Z-H-4.html#%_toc_%_sec_4.3.3">4.3.3  Implementing the <code>Amb</code> Evaluator</a></a></h3>
<p>The evaluation of an ordinary Scheme expression may
return a value, may never terminate, or may signal an error. In
nondeterministic Scheme the evaluation of an expression may in addition
result in the discovery of a dead end, in which case evaluation must
backtrack to a previous choice point. The interpretation of
nondeterministic Scheme is complicated by this extra case.</p>
<p>We will construct the <code>amb</code> evaluator for
nondeterministic Scheme by modifying the analyzing evaluator of
section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>.<a href="book-Z-H-28.html#footnote_Temp_629">^[55]{.small}^</a>
As in the analyzing evaluator, evaluation of an expression is
accomplished by calling an execution procedure produced
by analysis of that expression. The difference between the
interpretation of ordinary Scheme and the interpretation of
nondeterministic Scheme will be entirely in the execution procedures.</p>
<h4 id="execution-procedures-and-continuations"><a class="header" href="#execution-procedures-and-continuations"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_630">Execution procedures and continuations</a></a></h4>
<p>Recall that the execution procedures for
the ordinary evaluator take one argument: the environment of execution.
In contrast, the execution procedures in the <code>amb</code> evaluator take three
arguments: the environment, and two procedures called <em>continuation
procedures</em>. The evaluation of an expression will finish by calling one
of these two continuations: If the evaluation results in a value, the
<em>success continuation</em> is called with that value; if the
evaluation results in the discovery of a dead end, the
<em>failure continuation</em> is called. Constructing and
calling appropriate continuations is the mechanism by which the
nondeterministic evaluator implements backtracking.</p>
<p>It is the job of the success continuation to receive a value and proceed
with the computation. Along with that value, the success continuation is
passed another failure continuation, which is to be called subsequently
if the use of that value leads to a dead end.</p>
<p>It is the job of the failure continuation to try another branch of the
nondeterministic process. The essence of the nondeterministic language
is in the fact that expressions may represent choices among
alternatives. The evaluation of such an expression must proceed with one
of the indicated alternative choices, even though it is not known in
advance which choices will lead to acceptable results. To deal with
this, the evaluator picks one of the alternatives and passes this value
to the success continuation. Together with this value, the evaluator
constructs and passes along a failure continuation that can be called
later to choose a different alternative.</p>
<p>A failure is triggered during evaluation (that is, a failure
continuation is called) when a user program explicitly rejects the
current line of attack (for example, a call to <code>require</code> may result in
execution of <code>(amb)</code>, an expression that always fails -- see
section <a href="book-Z-H-28.html#%_sec_4.3.1">4.3.1</a>). The failure continuation
in hand at that point will cause the most recent choice point to choose
another alternative. If there are no more alternatives to be considered
at that choice point, a failure at an earlier choice point is triggered,
and so on. Failure continuations are also invoked by the driver loop in
response to a <code>try-again</code> request, to find another value of the
expression.</p>
<p>In addition, if a side-effect operation (such as assignment to a
variable) occurs on a branch of the process resulting from a choice, it
may be necessary, when the process finds a dead end, to undo the side
effect before making a new choice. This is accomplished by having the
side-effect operation produce a failure continuation that undoes the
side effect and propagates the failure.</p>
<p>In summary, failure continuations are constructed by</p>
<ul>
<li><code>amb</code> expressions -- to provide a mechanism to make alternative
choices if the current choice made by the <code>amb</code> expression leads to a
dead end;</li>
<li>the top-level driver -- to provide a mechanism to report failure when
the choices are exhausted;</li>
<li>assignments -- to intercept failures and undo assignments during
backtracking.</li>
</ul>
<p>Failures are initiated only when a dead end is encountered. This occurs</p>
<ul>
<li>if the user program executes <code>(amb)</code>;</li>
<li>if the user types <code>try-again</code> at the top-level driver.</li>
</ul>
<p>Failure continuations are also called during processing of a failure:</p>
<ul>
<li>When the failure continuation created by an assignment finishes
undoing a side effect, it calls the failure continuation it
intercepted, in order to propagate the failure back to the choice
point that led to this assignment or to the top level.</li>
<li>When the failure continuation for an <code>amb</code> runs out of choices, it
calls the failure continuation that was originally given to the <code>amb</code>,
in order to propagate the failure back to the previous choice point or
to the top level.</li>
</ul>
<h4 id="structure-of-the-evaluator"><a class="header" href="#structure-of-the-evaluator"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_631">Structure of the evaluator</a></a></h4>
<p>The syntax- and data-representation procedures for the
<code>amb</code> evaluator, and also the basic <code>analyze</code> procedure, are identical
to those in the evaluator of
section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>, except for the fact that
we need additional syntax procedures to recognize the <code>amb</code> special
form:<a href="book-Z-H-28.html#footnote_Temp_632">^[56]{.small}^</a></p>
<pre><code class="language-scheme editable">(define (amb? exp) (tagged-list? exp 'amb))
(define (amb-choices exp) (cdr exp))
</code></pre>
<p>We must also add to the dispatch in <code>analyze</code> a clause that will
recognize this special form and generate an appropriate execution
procedure:</p>
<p><code>((amb? exp) (analyze-amb exp))</code></p>
<p>The top-level procedure <code>ambeval</code> (similar to the version of <code>eval</code>
given in section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>) analyzes the
given expression and applies the resulting execution procedure to the
given environment, together with two given continuations:</p>
<pre><code class="language-scheme editable">(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
</code></pre>
<p>A success continuation is a
procedure of two arguments: the value just obtained and another failure
continuation to be used if that value leads to a subsequent failure. A
failure continuation is a procedure of no arguments. So
the general form of an execution procedure is</p>
<p><code>(lambda (env succeed fail)</code>
<code>  ;; succeed is (lambda (value fail) ...)</code>
<code>  ;; fail is (lambda () ...)</code>
<code>  ...)</code></p>
<p>For example, executing</p>
<p><code>(ambeval &lt;</code><em><code>exp</code></em><code>&gt;</code>
<code>         the-global-environment</code>
<code>         (lambda (value fail) value)</code>
<code>         (lambda () 'failed))</code></p>
<p>will attempt to evaluate the given expression and will return either the
expression's value (if the evaluation succeeds) or the symbol <code>failed</code>
(if the evaluation fails). The call to <code>ambeval</code> in the driver loop
shown below uses much more complicated continuation procedures, which
continue the loop and support the <code>try-again</code> request.</p>
<p>Most of the complexity of the <code>amb</code> evaluator results from the mechanics
of passing the continuations around as the execution procedures call
each other. In going through the following code, you should compare each
of the execution procedures with the corresponding procedure for the
ordinary evaluator given in
section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>.</p>
<h4 id="simple-expressions"><a class="header" href="#simple-expressions"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_633">Simple expressions</a></a></h4>
<p>The execution procedures for the simplest kinds of expressions are
essentially the same as those for the ordinary evaluator, except for the
need to manage the continuations. The execution procedures simply
succeed with the value of the expression, passing along the failure
continuation that was passed to them.</p>
<pre><code class="language-scheme editable">(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env succeed fail)
      (succeed qval fail))))
(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env)
             fail)))
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env)
               fail))))
</code></pre>
<p>Notice that looking up a variable always
''succeeds.'' If <code>lookup-variable-value</code> fails to find the variable,
it signals an error, as usual. Such a ''failure'' indicates a
program bug -- a reference to an unbound variable; it is not an
indication that we should try another nondeterministic choice instead of
the one that is currently being tried.</p>
<h4 id="conditionals-and-sequences"><a class="header" href="#conditionals-and-sequences"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_634">Conditionals and sequences</a></a></h4>
<p>Conditionals are also handled in a similar way as in the ordinary
evaluator. The execution procedure generated by <code>analyze-if</code> invokes the
predicate execution procedure <code>pproc</code> with a success continuation that
checks whether the predicate value is true and goes on to execute either
the consequent or the alternative. If the execution of <code>pproc</code> fails,
the original failure continuation for the <code>if</code> expression is called.</p>
<pre><code class="language-scheme editable">(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env succeed fail)
      (pproc env
             ;; success continuation for evaluating the predicate
             ;; to obtain pred-value
             (lambda (pred-value fail2)
               (if (true? pred-value)
                   (cproc env succeed fail2)
                   (aproc env succeed fail2)))
             ;; failure continuation for evaluating the predicate
             fail))))
</code></pre>
<p>Sequences are also handled in the same way as in the previous evaluator,
except for the machinations in the subprocedure <code>sequentially</code> that are
required for passing the continuations. Namely, to sequentially execute
<code>a</code> and then <code>b</code>, we call <code>a</code> with a success continuation that calls
<code>b</code>.</p>
<pre><code class="language-scheme editable">(define (analyze-sequence exps)
  (define (sequentially a b)
    (lambda (env succeed fail)
      (a env
         ; success continuation for calling a
         (lambda (a-value fail2)
           (b env succeed fail2))
         ; failure continuation for calling a
         fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence -- ANALYZE"))
    (loop (car procs) (cdr procs))))
</code></pre>
<h4 id="definitions-and-assignments"><a class="header" href="#definitions-and-assignments"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_635">Definitions and assignments</a></a></h4>
<p>Definitions are another case where we must go to some trouble to manage
the continuations, because it is necessary to evaluate the
definition-value expression before actually defining the new variable.
To accomplish this, the definition-value execution procedure <code>vproc</code> is
called with the environment, a success continuation, and the failure
continuation. If the execution of <code>vproc</code> succeeds, obtaining a value
<code>val</code> for the defined variable, the variable is defined and the success
is propagated:</p>
<pre><code class="language-scheme editable">(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env              
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
</code></pre>
<p>Assignments are more interesting. This is the first place
where we really use the continuations, rather than just passing them
around. The execution procedure for assignments starts out like the one
for definitions. It first attempts to obtain the new value to be
assigned to the variable. If this evaluation of <code>vproc</code> fails, the
assignment fails.</p>
<p>If <code>vproc</code> succeeds, however, and we go on to make the assignment, we
must consider the possibility that this branch of the computation might
later fail, which will require us to backtrack out of the assignment.
Thus, we must arrange to undo the assignment as part of the backtracking
process.<a href="book-Z-H-28.html#footnote_Temp_636">^[57]{.small}^</a></p>
<p>This is accomplished by giving <code>vproc</code> a success continuation (marked
with the comment ''<em>1</em>'' below) that saves the old value of the
variable before assigning the new value to the variable and proceeding
from the assignment. The failure continuation that is passed along with
the value of the assignment (marked with the comment ''<em>2</em>''
below) restores the old value of the variable before continuing the
failure. That is, a successful assignment provides a failure
continuation that will intercept a subsequent failure; whatever failure
would otherwise have called <code>fail2</code> calls this procedure instead, to
undo the assignment before actually calling <code>fail2</code>.</p>
<pre><code class="language-scheme editable">(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)         ; *1*
               (let ((old-value
                      (lookup-variable-value var env))) 
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()    ; *2*
                            (set-variable-value! var
                                                 old-value
                                                 env)
                            (fail2)))))
             fail))))
</code></pre>
<h4 id="procedure-applications"><a class="header" href="#procedure-applications"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_637">Procedure applications</a></a></h4>
<p>The execution procedure for applications contains no new ideas except
for the technical complexity of managing the continuations. This
complexity arises in <code>analyze-application</code>, due to the need to keep
track of the success and failure continuations as we evaluate the
operands. We use a procedure <code>get-args</code> to evaluate the list of
operands, rather than a simple <code>map</code> as in the ordinary evaluator.</p>
<pre><code class="language-scheme editable">(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
</code></pre>
<p>In <code>get-args</code>, notice how <code>cdr</code>ing down the list of <code>aproc</code> execution
procedures and <code>cons</code>ing up the resulting list of <code>args</code> is accomplished
by calling each <code>aproc</code> in the list with a success continuation that
recursively calls <code>get-args</code>. Each of these recursive calls to
<code>get-args</code> has a success continuation whose value is the <code>cons</code> of the
newly obtained argument onto the list of accumulated arguments:</p>
<pre><code class="language-scheme editable">(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs) env
                    ; success continuation for this aproc
                    (lambda (arg fail2)
                      (get-args (cdr aprocs)
                                env
                                ;; success continuation for recursive
                                ;; call to get-args
                                (lambda (args fail3)
                                  (succeed (cons arg args)
                                           fail3))
                                fail2))
                    fail)))
</code></pre>
<p>The actual procedure application, which is performed by
<code>execute-application</code>, is accomplished in the same way as for the
ordinary evaluator, except for the need to manage the continuations.</p>
<pre><code class="language-scheme editable">(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))
          succeed
          fail))
        (else
         (error
          "Unknown procedure type -- EXECUTE-APPLICATION"
          proc))))
</code></pre>
<h4 id="evaluating-amb-expressions"><a class="header" href="#evaluating-amb-expressions"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_638">Evaluating <code>amb</code> expressions</a></a></h4>
<p>The <code>amb</code> special form is the key element in the
nondeterministic language. Here we see the essence of the interpretation
process and the reason for keeping track of the continuations. The
execution procedure for <code>amb</code> defines a loop <code>try-next</code> that cycles
through the execution procedures for all the possible values of the
<code>amb</code> expression. Each execution procedure is called with a failure
continuation that will try the next one. When there are no more
alternatives to try, the entire <code>amb</code> expression fails.</p>
<pre><code class="language-scheme editable">(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices) env
                           succeed
                           (lambda ()
                             (try-next (cdr choices))))))
      (try-next cprocs))))
</code></pre>
<h4 id="driver-loop-1"><a class="header" href="#driver-loop-1"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_639">Driver loop</a></a></h4>
<p>The driver loop for the <code>amb</code> evaluator
is complex, due to the mechanism that permits the user to try again in
evaluating an expression. The driver uses a procedure called
<code>internal-loop</code>, which takes as argument a procedure <code>try-again</code>. The
intent is that calling <code>try-again</code> should go on to the next untried
alternative in the nondeterministic evaluation. <code>Internal-loop</code> either
calls <code>try-again</code> in response to the user typing <code>try-again</code> at the
driver loop, or else starts a new evaluation by calling <code>ambeval</code>.</p>
<p>The failure continuation for this call to <code>ambeval</code> informs the user
that there are no more values and re-invokes the driver loop.</p>
<p>The success continuation for the call to <code>ambeval</code> is more subtle. We
print the obtained value and then invoke the internal loop again with a
<code>try-again</code> procedure that will be able to try the next alternative.
This <code>next-alternative</code> procedure is the second argument that was passed
to the success continuation. Ordinarily, we think of this second
argument as a failure continuation to be used if the current evaluation
branch later fails. In this case, however, we have completed a
successful evaluation, so we can invoke the ''failure'' alternative
branch in order to search for additional successful evaluations.</p>
<pre><code class="language-scheme editable">(define input-prompt ";;; Amb-Eval input:")
(define output-prompt ";;; Amb-Eval value:")
(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline)
            (display ";;; Starting a new problem ")
            (ambeval input
                     the-global-environment
                     ;; ambeval success
                     (lambda (val next-alternative)
                       (announce-output output-prompt)
                       (user-print val)
                       (internal-loop next-alternative))
                     ;; ambeval failure
                     (lambda ()
                       (announce-output
                        ";;; There are no more values of")
                       (user-print input)
                       (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline)
     (display ";;; There is no current problem")
     (driver-loop))))
</code></pre>
<p>The initial call to <code>internal-loop</code> uses a <code>try-again</code> procedure that
complains that there is no current problem and restarts the driver loop.
This is the behavior that will happen if the user types <code>try-again</code> when
there is no evaluation in progress.</p>
<p><strong>Exercise 4.50.</strong>  Implement a new special form <code>ramb</code>
that is like <code>amb</code> except that it searches alternatives in a random
order, rather than from left to right. Show how this can help with
Alyssa's problem in exercise <a href="book-Z-H-28.html#%_thm_4.49">4.49</a>.</p>
<p><strong>Exercise 4.51.</strong>  Implement a new kind of assignment
called <code>permanent-set!</code> that is not undone upon failure. For example, we
can choose two distinct elements from a list and count the number of
trials required to make a successful choice as follows:</p>
<pre><code class="language-scheme editable">(define count 0)
(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))
</code></pre>
<p><em><code>;;; Starting a new problem</code></em>
<em><code>;;; Amb-Eval value:</code></em>
<em><code>(a b 2)</code></em>
<em><code>;;; Amb-Eval input:</code></em></p>
<pre><code class="language-scheme editable">try-again
</code></pre>
<p><em><code>;;; Amb-Eval value:</code></em>
<em><code>(a c 3)</code></em></p>
<p>What values would have been displayed if we had used <code>set!</code> here rather
than <code>permanent-set!</code> ?</p>
<p><strong>Exercise 4.52.</strong>  Implement a new construct called
<code>if-fail</code> that permits the user to catch the failure of an expression.
<code>If-fail</code> takes two expressions. It evaluates the first expression as
usual and returns as usual if the evaluation succeeds. If the evaluation
fails, however, the value of the second expression is returned, as in
the following example:</p>
<p><em><code>;;; Amb-Eval input:</code></em></p>
<pre><code class="language-scheme editable">(if-fail (let ((x (an-element-of '(1 3 5))))
           (require (even? x))
           x)
         'all-odd)
</code></pre>
<p><em><code>;;; Starting a new problem</code></em>
<em><code>;;; Amb-Eval value:</code></em>
<em><code>all-odd</code></em>
<em><code>;;; Amb-Eval input:</code></em></p>
<pre><code class="language-scheme editable">(if-fail (let ((x (an-element-of '(1 3 5 8))))
           (require (even? x))
           x)
         'all-odd)
</code></pre>
<p><em><code>;;; Starting a new problem</code></em>
<em><code>;;; Amb-Eval value:</code></em>
<em><code>8</code></em></p>
<p><strong>Exercise 4.53.</strong>  With <code>permanent-set!</code> as described
in exercise <a href="book-Z-H-28.html#%_thm_4.51">4.51</a> and <code>if-fail</code> as in
exercise <a href="book-Z-H-28.html#%_thm_4.52">4.52</a>, what will be the result of
evaluating</p>
<pre><code class="language-scheme editable">(let ((pairs '()))
  (if-fail (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))
             (permanent-set! pairs (cons p pairs))
             (amb))
           pairs))
</code></pre>
<p><strong>Exercise 4.54.</strong>  If we had not
realized that <code>require</code> could be implemented as an ordinary procedure
that uses <code>amb</code>, to be defined by the user as part of a nondeterministic
program, we would have had to implement it as a special form. This would
require syntax procedures</p>
<pre><code class="language-scheme editable">(define (require? exp) (tagged-list? exp 'require))

(define (require-predicate exp) (cadr exp))
</code></pre>
<p>and a new clause in the dispatch in <code>analyze</code></p>
<p><code>((require? exp) (analyze-require exp))</code></p>
<p>as well the procedure <code>analyze-require</code> that handles <code>require</code>
expressions. Complete the following definition of <code>analyze-require</code>.</p>
<pre><code class="language-scheme editable">(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if &lt;*??*&gt;
                   &lt;*??*&gt;
                   (succeed 'ok fail2)))
             fail))))
</code></pre>
<p>)</p>
<hr />
<p>)</p>
<p>)
^[42]{.small}^](book-Z-H-28.html#call_footnote_Temp_598)
We assume that we have previously defined a procedure <code>prime?</code> that
tests whether numbers are prime. Even with <code>prime?</code> defined, the
<code>prime-sum-pair</code> procedure may look suspiciously like the unhelpful
''pseudo-Lisp'' attempt to define the square-root function, which we
described at the beginning of
section <a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a>. In fact, a square-root
procedure along those lines can actually be formulated as a
nondeterministic program. By incorporating a search mechanism into the
evaluator, we are eroding the distinction
between purely declarative descriptions and imperative specifications of
how to compute answers. We'll go even farther in this direction in
section <a href="book-Z-H-29.html#%_sec_4.4">4.4</a>.</p>
<p>^[43]{.small}^](book-Z-H-28.html#call_footnote_Temp_599)
The idea of <code>amb</code> for nondeterministic programming was
first described in 1961 by John McCarthy (see McCarthy
1967).</p>
<p>^[44]{.small}^](book-Z-H-28.html#call_footnote_Temp_600)
In actuality, the distinction between nondeterministically returning a
single choice and returning all choices depends somewhat on our point of
view. From the perspective of the code that uses the value, the
nondeterministic choice returns a single value. From the perspective of
the programmer designing the code, the nondeterministic choice
potentially returns all possible values, and the computation branches so
that each value is investigated separately.</p>
<p>^[45]{.small}^](book-Z-H-28.html#call_footnote_Temp_601)
One might object that this is a hopelessly inefficient mechanism. It
might require millions of processors to solve some easily stated problem
this way, and most of the time most of those processors would be idle.
This objection should be taken in the context of history. Memory used to
be considered just such an expensive commodity. In 1964 a
megabyte of RAM cost about $400,000. Now every personal computer has
many megabytes of RAM, and most of the time most of that RAM is unused.
It is hard to underestimate the cost of mass-produced electronics.</p>
<p>^[46]{.small}^](book-Z-H-28.html#call_footnote_Temp_602)
Automagically: ''Automatically, but in a way which, for some reason
(typically because it is too complicated, or too ugly, or perhaps even
too trivial), the speaker doesn't feel like explaining.'' (Steele
1983, Raymond 1993)</p>
<p>^[47]{.small}^](book-Z-H-28.html#call_footnote_Temp_603)
The integration of automatic search strategies into
programming languages has had a long and checkered history. The first
suggestions that nondeterministic algorithms might be elegantly encoded
in a programming language with search and automatic backtracking came
from Robert Floyd (1967). Carl Hewitt
(1969) invented a programming language called Planner
that explicitly supported automatic chronological backtracking,
providing for a built-in depth-first search strategy.
Sussman, Winograd, and
Charniak (1971) implemented a subset of this language, called
MicroPlanner, which was used to support work in problem
solving and robot planning. Similar ideas, arising from logic and
theorem proving, led to the genesis in Edinburgh and Marseille of the
elegant language Prolog (which we will discuss in
section <a href="book-Z-H-29.html#%_sec_4.4">4.4</a>). After sufficient frustration
with automatic search, McDermott and
Sussman (1972) developed a language called Conniver,
which included mechanisms for placing the search strategy under
programmer control. This proved unwieldy, however, and
Sussman and Stallman (1975) found a more
tractable approach while investigating methods of symbolic analysis for
electrical circuits. They developed a non-chronological backtracking
scheme that was based on tracing out the logical dependencies connecting
facts, a technique that has come to be known as
<em>dependency-directed backtracking</em>. Although their method
was complex, it produced reasonably efficient programs because it did
little redundant search. Doyle (1979) and
McAllester (1978, 1980) generalized and clarified the methods of
Stallman and Sussman, developing a new paradigm for formulating search
that is now called <em>truth maintenance</em>. Modern
problem-solving systems all use some form of truth-maintenance system as
a substrate. See Forbus and deKleer 1993
for a discussion of elegant ways to build truth-maintenance systems and
applications using truth maintenance.
Zabih, McAllester, and
Chapman 1987 describes a nondeterministic extension to Scheme that is
based on <code>amb</code>; it is similar to the interpreter described in this
section, but more sophisticated, because it uses dependency-directed
backtracking rather than chronological backtracking.
Winston 1992 gives an introduction to both kinds of backtracking.</p>
<p>^[48]{.small}^](book-Z-H-28.html#call_footnote_Temp_609)
Our program uses the following procedure to determine if the elements of
a list are distinct:</p>
<pre><code class="language-scheme editable">(define (distinct? items)
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))
</code></pre>
<p><code>Member</code> is like <code>memq</code> except that it uses <code>equal?</code>
instead of <code>eq?</code> to test for equality.</p>
<p>^[49]{.small}^](book-Z-H-28.html#call_footnote_Temp_616)
This is taken from a booklet called ''Problematical Recreations,''
published in the 1960s by Litton Industries, where it is attributed to
the <em>Kansas State Engineer</em>.</p>
<p>^[50]{.small}^](book-Z-H-28.html#call_footnote_Temp_619)
Here we use the convention that the first element of each list
designates the part of speech for the rest of the words in the list.</p>
<p>^[51]{.small}^](book-Z-H-28.html#call_footnote_Temp_620)
Notice that <code>parse-word</code> uses <code>set!</code> to modify the unparsed input list.
For this to work, our <code>amb</code> evaluator must undo the effects of <code>set!</code>
operations when it backtracks.</p>
<p>^[52]{.small}^](book-Z-H-28.html#call_footnote_Temp_621)
Observe that this definition is recursive -- a verb may be followed by
any number of prepositional phrases.</p>
<p>^[53]{.small}^](book-Z-H-28.html#call_footnote_Temp_626)
This kind of grammar can become arbitrarily complex, but it
is only a toy as far as real language understanding is
concerned. Real natural-language understanding by computer requires an
elaborate mixture of syntactic analysis and interpretation of meaning.
On the other hand, even toy parsers can be useful in supporting flexible
command languages for programs such as information-retrieval systems.
Winston 1992 discusses computational approaches to real
language understanding and also the applications of simple grammars to
command languages.</p>
<p>^[54]{.small}^](book-Z-H-28.html#call_footnote_Temp_628)
Although Alyssa's idea works just fine (and is surprisingly simple),
the sentences that it generates are a bit boring -- they don't sample
the possible sentences of this language in a very interesting way. In
fact, the grammar is highly recursive in many places, and Alyssa's
technique ''falls into'' one of these recursions and gets stuck. See
exercise <a href="book-Z-H-28.html#%_thm_4.50">4.50</a> for a way to deal with
this.</p>
<p>^[55]{.small}^](book-Z-H-28.html#call_footnote_Temp_629)
We chose to implement the lazy evaluator in
section <a href="book-Z-H-27.html#%_sec_4.2">4.2</a> as a modification of the
ordinary metacircular evaluator of
section <a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>. In contrast, we will base
the <code>amb</code> evaluator on the analyzing evaluator of
section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>, because the execution
procedures in that evaluator provide a convenient framework for
implementing backtracking.</p>
<p>^[56]{.small}^](book-Z-H-28.html#call_footnote_Temp_632)
We assume that the evaluator supports <code>let</code> (see
exercise <a href="book-Z-H-26.html#%_thm_4.22">4.22</a>), which we have used in our
nondeterministic programs.</p>
<p>^[57]{.small}^](book-Z-H-28.html#call_footnote_Temp_636)
We didn't worry about undoing definitions, since we can
assume that internal definitions are scanned out
(section <a href="book-Z-H-26.html#%_sec_4.1.6">4.1.6</a>).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="4.2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="4.4.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="4.2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="4.4.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="./highlight.js"></script>
        <script src="./src/languages/scheme.min.js"></script>
        <script src="./biwascheme.min.js"></script>
        <script src="./biwascheme_run_logic.js"></script>


    </div>
    </body>
</html>
