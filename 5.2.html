<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A Register-Machine Simulator - SICP</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./src/styles/docco.min.css">
        <link rel="stylesheet" href="./run_button_style.css">
        <link rel="stylesheet" href="./custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SICP</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="52--a-register-machine-simulator"><a class="header" href="#52--a-register-machine-simulator"><a href="book-Z-H-4.html#%_toc_%_sec_5.2">5.2  A Register-Machine Simulator</a></a></h2>
<p>In order to gain a good understanding of
the design of register machines, we must test the machines we design to
see if they perform as expected. One way to test a design is to
hand-simulate the operation of the controller, as in
exercise <a href="book-Z-H-31.html#%_thm_5.5">5.5</a>. But this is extremely
tedious for all but the simplest machines. In this section we construct
a simulator for machines described in the register-machine language. The
simulator is a Scheme program with four interface procedures. The first
uses a description of a register machine to construct a model of the
machine (a data structure whose parts correspond to the parts of the
machine to be simulated), and the other three allow us to simulate thev
machine by manipulating the model:</p>
<blockquote>
<pre><code class="language-scheme editable">(make-machine &lt;`*`register-names`*`&gt; &lt;`*`operations`*`&gt; &lt;`*`controller`*`&gt;)
</code></pre>
<p>constructs and returns a model of the machine with the given
registers, operations, and controller.</p>
<pre><code class="language-scheme editable">(set-register-contents! &lt;`*`machine-model`*`&gt; &lt;`*`register-name`*`&gt; &lt;`*`value`*`&gt;)
</code></pre>
<p>stores a value in a simulated register in the given machine.</p>
<pre><code class="language-scheme editable">(get-register-contents &lt;`*`machine-model`*`&gt; &lt;`*`register-name`*`&gt;)
</code></pre>
<p>returns the contents of a simulated register in the given machine.</p>
<pre><code class="language-scheme editable">(start &lt;`*`machine`*`&gt;)
</code></pre>
<p>simulates the execution of the given machine, starting from the
beginning of the controller sequence and stopping when it reaches the
end of the sequence.</p>
</blockquote>
<p>As an example of how these procedures are used, we can define
<code>gcd-machine</code> to be a model of the GCD machine of
section <a href="book-Z-H-31.html#%_sec_5.1.1">5.1.1</a> as follows:</p>
<pre><code class="language-scheme editable">(define gcd-machine
  (make-machine
   '(a b t)
   (list (list 'rem remainder) (list '= =))
   '(test-b
       (test (op =) (reg b) (const 0))
       (branch (label gcd-done))
       (assign t (op rem) (reg a) (reg b))
       (assign a (reg b))
       (assign b (reg t))
       (goto (label test-b))
     gcd-done)))
</code></pre>
<p>The first argument to <code>make-machine</code> is a list of register names. The
next argument is a table (a list of two-element lists) that pairs each
operation name with a Scheme procedure that implements the operation
(that is, produces the same output value given the same input values).
The last argument specifies the controller as a list of labels and
machine instructions, as in section <a href="book-Z-H-31.html#%_sec_5.1">5.1</a>.</p>
<p>To compute GCDs with this machine, we set the input registers, start the
machine, and examine the result when the simulation terminates:</p>
<pre><code class="language-scheme editable">(set-register-contents! gcd-machine 'a 206)
</code></pre>
<p><em><code>done</code></em></p>
<pre><code class="language-scheme editable">(set-register-contents! gcd-machine 'b 40)
</code></pre>
<p><em><code>done</code></em></p>
<pre><code class="language-scheme editable">(start gcd-machine)
</code></pre>
<p><em><code>done</code></em></p>
<pre><code class="language-scheme editable">(get-register-contents gcd-machine 'a)
</code></pre>
<p><em><code>2</code></em></p>
<p>This computation will run much more slowly than a <code>gcd</code> procedure
written in Scheme, because we will simulate low-level machine
instructions, such as <code>assign</code>, by much more complex operations.</p>
<p><strong>Exercise 5.7.</strong>  Use the simulator to test the machines
you designed in exercise <a href="book-Z-H-31.html#%_thm_5.4">5.4</a>.</p>
<h3 id="521--the-machine-model"><a class="header" href="#521--the-machine-model"><a href="book-Z-H-4.html#%_toc_%_sec_5.2.1">5.2.1  The Machine Model</a></a></h3>
<p>The machine model generated by <code>make-machine</code> is represented as a
procedure with local state using the message-passing techniques
developed in chapter 3. To build this model, <code>make-machine</code> begins by
calling the procedure <code>make-new-machine</code> to construct the parts of the
machine model that are common to all register machines. This basic
machine model constructed by <code>make-new-machine</code> is essentially a
container for some registers and a stack, together with an execution
mechanism that processes the controller instructions one by one.</p>
<p><code>Make-machine</code> then extends this basic model (by sending it messages) to
include the registers, operations, and controller of the particular
machine being defined. First it allocates a register in the new machine
for each of the supplied register names and installs the designated
operations in the machine. Then it uses an <em>assembler</em>
(described below in section <a href="book-Z-H-32.html#%_sec_5.2.2">5.2.2</a>) to
transform the controller list into instructions for the new machine and
installs these as the machine's instruction sequence. <code>Make-machine</code>
returns as its value the modified machine model.</p>
<pre><code class="language-scheme editable">(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each (lambda (register-name)
                ((machine 'allocate-register) register-name))
              register-names)
    ((machine 'install-operations) ops)    
    ((machine 'install-instruction-sequence)
     (assemble controller-text machine))
    machine))
</code></pre>
<h4 id="registers"><a class="header" href="#registers"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_724">Registers</a></a></h4>
<p>We will represent a register as a procedure with local
state, as in chapter 3. The procedure <code>make-register</code> creates a register
that holds a value that can be accessed or changed:</p>
<pre><code class="language-scheme editable">(define (make-register name)
  (let ((contents '*unassigned*))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value) (set! contents value)))
            (else
             (error "Unknown request -- REGISTER" message))))
    dispatch))
</code></pre>
<p>The following procedures are used to access registers:</p>
<pre><code class="language-scheme editable">(define (get-contents register)
  (register 'get))
</code></pre>
<pre><code class="language-scheme editable">(define (set-contents! register value)
  ((register 'set) value))
</code></pre>
<h4 id="the-stack"><a class="header" href="#the-stack"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_725">The stack</a></a></h4>
<p>We can also represent a stack as a procedure with local
state. The procedure <code>make-stack</code> creates a stack whose local state
consists of a list of the items on the stack. A stack accepts requests
to <code>push</code> an item onto the stack, to <code>pop</code> the top item off the stack
and return it, and to <code>initialize</code> the stack to empty.</p>
<pre><code class="language-scheme editable">(define (make-stack)
  (let ((s '()))
    (define (push x)
      (set! s (cons x s)))
    (define (pop)
      (if (null? s)
          (error "Empty stack -- POP")
          (let ((top (car s)))
            (set! s (cdr s))
            top)))
    (define (initialize)
      (set! s '())
      'done)
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            (else (error "Unknown request -- STACK"
                         message))))
    dispatch))
</code></pre>
<p>The following procedures are used to access stacks:</p>
<pre><code class="language-scheme editable">(define (pop stack)
  (stack 'pop))
</code></pre>
<pre><code class="language-scheme editable">(define (push stack value)
  ((stack 'push) value))
</code></pre>
<h4 id="the-basic-machine"><a class="header" href="#the-basic-machine"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_726">The basic machine</a></a></h4>
<p>The <code>make-new-machine</code> procedure, shown in
figure <a href="book-Z-H-32.html#%_fig_5.13">5.13</a>, constructs an object whose
local state consists of a stack, an initially empty instruction
sequence, a list of operations that initially contains an operation to
initialize the stack, and a <em>register
table</em> that initially contains two
registers, named <code>flag</code> and <code>pc</code>
(for ``program counter''). The internal procedure
<code>allocate-register</code> adds new entries to the register table, and the
internal procedure <code>lookup-register</code> looks up registers in the table.</p>
<p>The <code>flag</code> register is used to control branching in the simulated
machine. <code>Test</code> instructions set the contents of <code>flag</code> to the result of
the test (true or false). <code>Branch</code> instructions decide whether or not to
branch by examining the contents of <code>flag</code>.</p>
<p>The <code>pc</code> register determines the sequencing of instructions as the
machine runs. This sequencing is implemented by the internal procedure
<code>execute</code>. In the simulation model, each machine instruction is a data
structure that includes a procedure of no arguments, called the
<em>instruction execution procedure</em>, such
that calling this procedure simulates executing the instruction. As the
simulation runs, <code>pc</code> points to the place in the instruction sequence
beginning with the next instruction to be executed.
<code>Execute</code> gets that instruction, executes it by calling
the instruction execution procedure, and repeats this cycle until there
are no more instructions to execute (i.e., until <code>pc</code> points to the end
of the instruction sequence).</p>
<pre><code class="language-scheme editable">(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Multiply defined register: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table))))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Unknown register:" name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq) (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register) allocate-register)
              ((eq? message 'get-register) lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              (else (error "Unknown request -- MACHINE" message))))
      dispatch)))
</code></pre>
<p><strong>Figure 5.13:</strong>  The <code>make-new-machine</code> procedure, which implements the
basic machine model.</p>
<p>As part of its operation, each instruction execution procedure modifies
<code>pc</code> to indicate the next instruction to be executed. <code>Branch</code> and
<code>goto</code> instructions change <code>pc</code> to point to the new destination. All
other instructions simply advance <code>pc</code>, making it point to the next
instruction in the sequence. Observe that each call to <code>execute</code> calls
<code>execute</code> again, but this does not produce an infinite loop because
running the instruction execution procedure changes the contents of
<code>pc</code>.</p>
<p><code>Make-new-machine</code> returns a <code>dispatch</code> procedure that implements
message-passing access to the internal state. Notice that starting the
machine is accomplished by setting <code>pc</code> to the beginning of the
instruction sequence and calling <code>execute</code>.</p>
<p>For convenience, we provide an alternate procedural interface to a
machine's <code>start</code> operation, as well as procedures to set and examine
register contents, as specified at the beginning of
section <a href="book-Z-H-32.html#%_sec_5.2">5.2</a>:</p>
<pre><code class="language-scheme editable">(define (start machine)
  (machine 'start))
</code></pre>
<pre><code class="language-scheme editable">(define (get-register-contents machine register-name)
  (get-contents (get-register machine register-name)))
</code></pre>
<pre><code class="language-scheme editable">(define (set-register-contents! machine register-name value)
  (set-contents! (get-register machine register-name) value)
  'done)
</code></pre>
<p>These procedures (and many procedures in
sections <a href="book-Z-H-32.html#%_sec_5.2.2">5.2.2</a> and
<a href="book-Z-H-32.html#%_sec_5.2.3">5.2.3</a>) use the following to look up the
register with a given name in a given machine:</p>
<pre><code class="language-scheme editable">(define (get-register machine reg-name)
  ((machine 'get-register) reg-name))
</code></pre>
<h3 id="522--the-assembler"><a class="header" href="#522--the-assembler"><a href="book-Z-H-4.html#%_toc_%_sec_5.2.2">5.2.2  The Assembler</a></a></h3>
<p>The assembler transforms the sequence of controller
expressions for a machine into a corresponding list of machine
instructions, each with its execution procedure. Overall, the assembler
is much like the evaluators we studied in chapter 4 -- there is an
input language (in this case, the register-machine language) and we must
perform an appropriate action for each type of expression in the
language.</p>
<p>The technique of producing an execution procedure for
each instruction is just what we used in
section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a> to speed up the evaluator
by separating analysis from runtime execution. As we saw in chapter 4,
much useful analysis of Scheme expressions could be performed without
knowing the actual values of variables. Here, analogously, much useful
analysis of register-machine-language expressions can be performed
without knowing the actual contents of machine registers. For example,
we can replace references to registers by pointers to the register
objects, and we can replace references to labels by pointers to the
place in the instruction sequence that the label designates.</p>
<p>Before it can generate the instruction execution procedures, the
assembler must know what all the labels refer to, so it begins by
scanning the controller text to separate the labels from the
instructions. As it scans the text, it constructs both a list of
instructions and a table that associates each label with a pointer into
that list. Then the assembler augments the instruction list by inserting
the execution procedure for each instruction.</p>
<p>The <code>assemble</code> procedure is the main entry to the assembler. It takes
the controller text and the machine model as arguments and returns the
instruction sequence to be stored in the model. <code>Assemble</code> calls
<code>extract-labels</code> to build the initial instruction list and label table
from the supplied controller text. The second argument to
<code>extract-labels</code> is a procedure to be called to process these results:
This procedure uses <code>update-insts!</code> to generate the instruction
execution procedures and insert them into the instruction list, and
returns the modified list.</p>
<pre><code class="language-scheme editable">(define (assemble controller-text machine)
  (extract-labels controller-text
    (lambda (insts labels)
      (update-insts! insts labels machine)
      insts)))
</code></pre>
<p><code>Extract-labels</code> takes as arguments a list <code>text</code> (the sequence of
controller instruction expressions) and a <code>receive</code> procedure. <code>Receive</code>
will be called with two values: (1) a list <code>insts</code> of instruction data
structures, each containing an instruction from <code>text</code>; and (2) a table
called <code>labels</code>, which associates each label from <code>text</code> with the
position in the list <code>insts</code> that the label designates.</p>
<pre><code class="language-scheme editable">(define (extract-labels text receive)
  (if (null? text)
      (receive '() '())
      (extract-labels (cdr text)
        (lambda (insts labels)
          (let ((next-inst (car text)))
            (if (symbol? next-inst)
                (receive insts
                         (cons (make-label-entry next-inst
                                                 insts)
                               labels))
                (receive (cons (make-instruction next-inst)
                               insts)
                         labels))))))
</code></pre>
<p><code>Extract-labels</code> works by sequentially scanning the elements of the
<code>text</code> and accumulating the <code>insts</code> and the <code>labels</code>. If an element is a
symbol (and thus a label) an appropriate entry is added to the <code>labels</code>
table. Otherwise the element is accumulated onto the <code>insts</code>
list.<a href="book-Z-H-32.html#footnote_Temp_727">^[4]{.small}^</a></p>
<p><code>Update-insts!</code> modifies the instruction list, which initially contains
only the text of the instructions, to include the corresponding
execution procedures:</p>
<pre><code class="language-scheme editable">(define (update-insts! insts labels machine)
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stack (machine 'stack))
        (ops (machine 'operations)))
    (for-each
     (lambda (inst)
       (set-instruction-execution-proc! 
        inst
        (make-execution-procedure
         (instruction-text inst) labels machine
         pc flag stack ops)))
     insts)))
</code></pre>
<p>The machine instruction data structure simply pairs the instruction text
with the corresponding execution procedure. The execution procedure is
not yet available when <code>extract-labels</code> constructs the instruction, and
is inserted later by <code>update-insts!</code>.</p>
<pre><code class="language-scheme editable">(define (make-instruction text)
  (cons text '()))
</code></pre>
<pre><code class="language-scheme editable">(define (instruction-text inst)
  (car inst))
</code></pre>
<pre><code class="language-scheme editable">(define (instruction-execution-proc inst)
  (cdr inst))
</code></pre>
<pre><code class="language-scheme editable">(define (set-instruction-execution-proc! inst proc)
  (set-cdr! inst proc))
</code></pre>
<p>The instruction text is not used by our simulator, but it is handy to
keep around for debugging (see
exercise <a href="book-Z-H-32.html#%_thm_5.16">5.16</a>).</p>
<p>Elements of the label table are pairs:</p>
<pre><code class="language-scheme editable">(define (make-label-entry label-name insts)
  (cons label-name insts))
</code></pre>
<p>Entries will be looked up in the table with</p>
<pre><code class="language-scheme editable">(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        (error "Undefined label -- ASSEMBLE" label-name))))
</code></pre>
<p><strong>Exercise 5.8.</strong>  The following register-machine code is
ambiguous, because the label <code>here</code> is defined more than once:</p>
<pre><code class="language-scheme editable">start
  (goto (label here))
here
  (assign a (const 3))
  (goto (label there))
here
  (assign a (const 4))
  (goto (label there))
there
</code></pre>
<p>With the simulator as written, what will the contents of register <code>a</code> be
when control reaches <code>there</code>? Modify the <code>extract-labels</code> procedure so
that the assembler will signal an error if the same label name is used
to indicate two different locations.</p>
<h3 id="523--generating-execution-procedures-for-instructions"><a class="header" href="#523--generating-execution-procedures-for-instructions"><a href="book-Z-H-4.html#%_toc_%_sec_5.2.3">5.2.3  Generating Execution Procedures for Instructions</a></a></h3>
<p>The assembler calls <code>make-execution-procedure</code> to
generate the execution procedure for an instruction. Like the <code>analyze</code>
procedure in the evaluator of
section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>, this dispatches on the
type of instruction to generate the appropriate execution procedure.</p>
<pre><code class="language-scheme editable">(define (make-execution-procedure inst labels machine
                                  pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else (error "Unknown instruction type -- ASSEMBLE"
                     inst))))
</code></pre>
<p>For each type of instruction in the register-machine language, there is
a generator that builds an appropriate execution procedure. The details
of these procedures determine both the syntax and meaning of the
individual instructions in the register-machine language. We use data
abstraction to isolate the detailed syntax of register-machine
expressions from the general execution mechanism, as we did for
evaluators in section <a href="book-Z-H-26.html#%_sec_4.1.2">4.1.2</a>, by using
syntax procedures to extract and classify the parts of an instruction.</p>
<h4 id="assign-instructions"><a class="header" href="#assign-instructions"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_729"><code>Assign</code> instructions</a></a></h4>
<p>The <code>make-assign</code> procedure handles <code>assign</code>
instructions:</p>
<pre><code class="language-scheme editable">(define (make-assign inst machine labels operations pc)
  (let ((target
         (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()         ; execution procedure for ``assign`
        (set-contents! target (value-proc))
        (advance-pc pc)))))
</code></pre>
<p><code>Make-assign</code> extracts the target register name (the second element of
the instruction) and the value expression (the rest of the list that
forms the instruction) from the <code>assign</code> instruction using the selectors</p>
<pre><code class="language-scheme editable">(define (assign-reg-name assign-instruction)
  (cadr assign-instruction))
</code></pre>
<pre><code class="language-scheme editable">(define (assign-value-exp assign-instruction)
  (cddr assign-instruction))
</code></pre>
<p>The register name is looked up with <code>get-register</code> to produce the target
register object. The value expression is passed to <code>make-operation-exp</code>
if the value is the result of an operation, and to <code>make-primitive-exp</code>
otherwise. These procedures (shown below) parse the value expression and
produce an execution procedure for the value. This is a procedure of no
arguments, called <code>value-proc</code>, which will be evaluated
during the simulation to produce the actual value to be assigned to the
register. Notice that the work of looking up the register name and
parsing the value expression is performed just once, at assembly time,
not every time the instruction is simulated. This saving of work is the
reason we use execution procedures, and corresponds
directly to the saving in work we obtained by separating program
analysis from execution in the evaluator of
section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>.</p>
<p>The result returned by <code>make-assign</code> is the execution procedure for the
<code>assign</code> instruction. When this procedure is called (by the machine
model's <code>execute</code> procedure), it sets the contents of the target
register to the result obtained by executing <code>value-proc</code>. Then it
advances the <code>pc</code> to the next instruction by running the procedure</p>
<pre><code class="language-scheme editable">(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc))))
</code></pre>
<p><code>Advance-pc</code> is the normal termination for all instructions except
<code>branch</code> and <code>goto</code>.</p>
<h4 id="test-branch-and-goto-instructions"><a class="header" href="#test-branch-and-goto-instructions"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_730"><code>Test</code>, <code>branch</code>, and <code>goto</code> instructions</a></a></h4>
<p><code>Make-test</code> handles <code>test</code> instructions in a similar way.
It extracts the expression that specifies the condition to be tested and
generates an execution procedure for it. At simulation time, the
procedure for the condition is called, the result is assigned to the
<code>flag</code> register, and the <code>pc</code> is advanced:</p>
<pre><code class="language-scheme editable">(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error "Bad TEST instruction -- ASSEMBLE" inst))))
</code></pre>
<pre><code class="language-scheme editable">(define (test-condition test-instruction)
  (cdr test-instruction))
</code></pre>
<p>The execution procedure for a <code>branch</code> instruction checks
the contents of the <code>flag</code> register and either sets the contents of the
<code>pc</code> to the branch destination (if the branch is taken) or else just
advances the <code>pc</code> (if the branch is not taken). Notice that the
indicated destination in a <code>branch</code> instruction must be a label, and the
<code>make-branch</code> procedure enforces this. Notice also that the label is
looked up at assembly time, not each time the <code>branch</code> instruction is
simulated.</p>
<pre><code class="language-scheme editable">(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label labels (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error "Bad BRANCH instruction -- ASSEMBLE" inst))))
</code></pre>
<pre><code class="language-scheme editable">(define (branch-dest branch-instruction)
  (cadr branch-instruction))
</code></pre>
<p>A <code>goto</code> instruction is similar to a branch, except that
the destination may be specified either as a label or as a register, and
there is no condition to check -- the <code>pc</code> is always set to the new
destination.</p>
<pre><code class="language-scheme editable">(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (get-register machine
                                (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction -- ASSEMBLE"
                       inst)))))
</code></pre>
<pre><code class="language-scheme editable">(define (goto-dest goto-instruction)
  (cadr goto-instruction))
</code></pre>
<h4 id="other-instructions"><a class="header" href="#other-instructions"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_731">Other instructions</a></a></h4>
<p>The stack instructions <code>save</code> and <code>restore</code> simply use the stack with
the designated register and advance the <code>pc</code>:</p>
<pre><code class="language-scheme editable">(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
                         (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))
</code></pre>
<pre><code class="language-scheme editable">(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
                         (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))    
      (advance-pc pc))))
</code></pre>
<pre><code class="language-scheme editable">(define (stack-inst-reg-name stack-instruction)
  (cadr stack-instruction))
</code></pre>
<p>The final instruction type, handled by <code>make-perform</code>,
generates an execution procedure for the action to be performed. At
simulation time, the action procedure is executed and the <code>pc</code> advanced.</p>
<pre><code class="language-scheme editable">(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action machine labels operations)))
          (lambda ()
            (action-proc)
            (advance-pc pc)))
        (error "Bad PERFORM instruction -- ASSEMBLE" inst))))
</code></pre>
<pre><code class="language-scheme editable">(define (perform-action inst) (cdr inst))
</code></pre>
<h4 id="execution-procedures-for-subexpressions"><a class="header" href="#execution-procedures-for-subexpressions"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_732">Execution procedures for subexpressions</a></a></h4>
<p>The value of a <code>reg</code>,
<code>label</code>, or <code>const</code> expression may be needed for assignment to a
register (<code>make-assign</code>) or for input to an operation
(<code>make-operation-exp</code>, below). The following procedure generates
execution procedures to produce values for these expressions during the
simulation:</p>
<pre><code class="language-scheme editable">(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label labels
                              (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine
                              (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error "Unknown expression type -- ASSEMBLE" exp))))
</code></pre>
<p>The syntax of <code>reg</code>, <code>label</code>, and <code>const</code> expressions is determined by</p>
<pre><code class="language-scheme editable">(define (register-exp? exp) (tagged-list? exp 'reg))
</code></pre>
<pre><code class="language-scheme editable">(define (register-exp-reg exp) (cadr exp))
</code></pre>
<pre><code class="language-scheme editable">(define (constant-exp? exp) (tagged-list? exp 'const))
</code></pre>
<pre><code class="language-scheme editable">(define (constant-exp-value exp) (cadr exp))
</code></pre>
<pre><code class="language-scheme editable">(define (label-exp? exp) (tagged-list? exp 'label))
</code></pre>
<pre><code class="language-scheme editable">(define (label-exp-label exp) (cadr exp))
</code></pre>
<p><code>Assign</code>, <code>perform</code>, and <code>test</code> instructions may include
the application of a machine operation (specified by an <code>op</code> expression)
to some operands (specified by <code>reg</code> and <code>const</code> expressions). The
following procedure produces an execution procedure for an ``operation
expression'' -- a list containing the operation and operand
expressions from the instruction:</p>
<pre><code class="language-scheme editable">(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs
         (map (lambda (e)
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
</code></pre>
<p>The syntax of operation expressions is determined by</p>
<pre><code class="language-scheme editable">(define (operation-exp? exp)
  (and (pair? exp) (tagged-list? (car exp) 'op)))
</code></pre>
<pre><code class="language-scheme editable">(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))
</code></pre>
<pre><code class="language-scheme editable">(define (operation-exp-operands operation-exp)
  (cdr operation-exp))
</code></pre>
<p>Observe that the treatment of operation expressions is very much like
the treatment of procedure applications by the <code>analyze-application</code>
procedure in the evaluator of
section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a> in that we generate an
execution procedure for each operand. At simulation time, we call the
operand procedures and apply the Scheme procedure that simulates the
operation to the resulting values. The simulation procedure is found by
looking up the operation name in the operation table for the machine:</p>
<pre><code class="language-scheme editable">(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Unknown operation -- ASSEMBLE" symbol))))
</code></pre>
<p><strong>Exercise 5.9.</strong>  The treatment of machine operations
above permits them to operate on labels as well as on constants and the
contents of registers. Modify the expression-processing procedures to
enforce the condition that operations can be used only with registers
and constants.</p>
<p><strong>Exercise 5.10.</strong>  Design a new syntax for
register-machine instructions and modify the simulator to use your new
syntax. Can you implement your new syntax without changing any part of
the simulator except the syntax procedures in this section?</p>
<p><strong>Exercise 5.11.</strong>  When
we introduced <code>save</code> and <code>restore</code> in
section <a href="book-Z-H-31.html#%_sec_5.1.4">5.1.4</a>, we didn't specify what
would happen if you tried to restore a register that was not the last
one saved, as in the sequence</p>
<pre><code class="language-scheme editable">(save y)
(save x)
(restore y)
</code></pre>
<p>There are several reasonable possibilities for the meaning of <code>restore</code>:</p>
<p>a.  <code>(restore y)</code> puts into <code>y</code> the last value saved on the stack,
regardless of what register that value came from. This is the way our
simulator behaves. Show how to take advantage of this behavior to
eliminate one instruction from the Fibonacci machine of
section <a href="book-Z-H-31.html#%_sec_5.1.4">5.1.4</a>
(figure <a href="book-Z-H-31.html#%_fig_5.12">5.12</a>).</p>
<p>b.  <code>(restore y)</code> puts into <code>y</code> the last value saved on the stack, but
only if that value was saved from <code>y</code>; otherwise, it signals an error.
Modify the simulator to behave this way. You will have to change <code>save</code>
to put the register name on the stack along with the value.</p>
<p>c.  <code>(restore y)</code> puts into <code>y</code> the last value saved from <code>y</code> regardless
of what other registers were saved after <code>y</code> and not restored. Modify
the simulator to behave this way. You will have to associate a separate
stack with each register. You should make the <code>initialize-stack</code>
operation initialize all the register stacks.</p>
<p><strong>Exercise 5.12.</strong>  The simulator can be used to help
determine the data paths required for implementing a machine with a
given controller. Extend the assembler to store the following
information in the machine model:</p>
<ul>
<li>a list of all instructions, with duplicates removed, sorted by
instruction type (<code>assign</code>, <code>goto</code>, and so on);</li>
<li>a list (without duplicates) of the registers used to hold entry points
(these are the registers referenced by <code>goto</code> instructions);</li>
<li>a list (without duplicates) of the registers that are <code>save</code>d or
<code>restore</code>d;</li>
<li>for each register, a list (without duplicates) of the sources from
which it is assigned (for example, the sources for register <code>val</code> in
the factorial machine of figure <a href="book-Z-H-31.html#%_fig_5.11">5.11</a>
are <code>(const 1)</code> and <code>((op *) (reg n) (reg val))</code>).</li>
</ul>
<p>Extend the message-passing interface to the machine to provide access to
this new information. To test your analyzer, define the Fibonacci
machine from figure <a href="book-Z-H-31.html#%_fig_5.12">5.12</a> and examine the
lists you constructed.</p>
<p><strong>Exercise 5.13.</strong>  Modify the simulator so that it uses
the controller sequence to determine what registers the machine has
rather than requiring a list of registers as an argument to
<code>make-machine</code>. Instead of pre-allocating the registers in
<code>make-machine</code>, you can allocate them one at a time when they are first
seen during assembly of the instructions.</p>
<h3 id="524--monitoring-machine-performance"><a class="header" href="#524--monitoring-machine-performance"><a href="book-Z-H-4.html#%_toc_%_sec_5.2.4">5.2.4  Monitoring Machine Performance</a></a></h3>
<p>Simulation is useful not only for
verifying the correctness of a proposed machine design but also for
measuring the machine's performance. For example, we can install in our
simulation program a ``meter'' that measures the number of stack
operations used in a computation. To do this, we modify our simulated
stack to keep track of the number of times registers are saved on the
stack and the maximum depth reached by the stack, and add a message to
the stack's interface that prints the statistics, as shown below. We
also add an operation to the basic machine model to print the stack
statistics, by initializing <code>the-ops</code> in <code>make-new-machine</code> to</p>
<pre><code class="language-scheme editable">(list (list 'initialize-stack
            (lambda () (stack 'initialize)))
      (list 'print-stack-statistics
            (lambda () (stack 'print-statistics))))
</code></pre>
<p>Here is the new version of <code>make-stack</code>:</p>
<pre><code class="language-scheme editable">(define (make-stack)
  (let ((s '())
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth)))
    (define (pop)
      (if (null? s)
          (error "Empty stack -- POP")
          (let ((top (car s)))
            (set! s (cdr s))
            (set! current-depth (- current-depth 1))
            top)))    
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      'done)
    (define (print-statistics)
      (newline)
      (display (list 'total-pushes  '= number-pushes
                     'maximum-depth '= max-depth)))
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            ((eq? message 'print-statistics)
             (print-statistics))
            (else
             (error "Unknown request -- STACK" message))))
    dispatch))
</code></pre>
<p>Exercises <a href="book-Z-H-32.html#%_thm_5.15">5.15</a>
through <a href="book-Z-H-32.html#%_thm_5.19">5.19</a> describe other useful
monitoring and debugging features that can be added to the
register-machine simulator.</p>
<p><strong>Exercise 5.14.</strong>  Measure the number of
pushes and the maximum stack depth required to compute <em>n</em>! for various
small values of <em>n</em> using the factorial machine shown in
figure <a href="book-Z-H-31.html#%_fig_5.11">5.11</a>. From your data determine
formulas in terms of <em>n</em> for the total number of push operations and the
maximum stack depth used in computing <em>n</em>! for any <em>n</em> &gt; 1. Note that
each of these is a linear function of <em>n</em> and is thus determined by two
constants. In order to get the statistics printed, you will have to
augment the factorial machine with instructions to initialize the stack
and print the statistics. You may want to also modify the machine so
that it repeatedly reads a value for <em>n</em>, computes the factorial, and
prints the result (as we did for the GCD machine in
figure <a href="book-Z-H-31.html#%_fig_5.4">5.4</a>), so that you will not have to
repeatedly invoke <code>get-register-contents</code>, <code>set-register-contents!</code>, and
<code>start</code>.</p>
<p><strong>Exercise 5.15.</strong>  Add <em>instruction
counting</em> to the register machine simulation. That is, have the machine
model keep track of the number of instructions executed. Extend the
machine model's interface to accept a new message that prints the value
of the instruction count and resets the count to zero.</p>
<p><strong>Exercise 5.16.</strong>  Augment the simulator to provide for
<em>instruction tracing</em>. That is, before
each instruction is executed, the simulator should print the text of the
instruction. Make the machine model accept <code>trace-on</code> and <code>trace-off</code>
messages to turn tracing on and off.</p>
<p><strong>Exercise 5.17.</strong>  Extend the instruction tracing of
exercise <a href="book-Z-H-32.html#%_thm_5.16">5.16</a> so that before printing an
instruction, the simulator prints any labels that immediately precede
that instruction in the controller sequence. Be careful to do this in a
way that does not interfere with instruction counting
(exercise <a href="book-Z-H-32.html#%_thm_5.15">5.15</a>). You will have to make
the simulator retain the necessary label information.</p>
<p><strong>Exercise 5.18.</strong>  Modify
the <code>make-register</code> procedure of
section <a href="book-Z-H-32.html#%_sec_5.2.1">5.2.1</a> so that registers can be
traced. Registers should accept messages that turn tracing on and off.
When a register is traced, assigning a value to the register should
print the name of the register, the old contents of the register, and
the new contents being assigned. Extend the interface to the machine
model to permit you to turn tracing on and off for designated machine
registers.</p>
<p><strong>Exercise 5.19.</strong>  Alyssa P. Hacker wants a
<em>breakpoint</em> feature in the simulator to help her debug
her machine designs. You have been hired to install this feature for
her. She wants to be able to specify a place in the controller sequence
where the simulator will stop and allow her to examine the state of the
machine. You are to implement a procedure</p>
<pre><code class="language-scheme editable">(set-breakpoint &lt;`*`machine`*`&gt; &lt;`*`label`*`&gt; &lt;`*`n`*`&gt;)
</code></pre>
<p>that sets a breakpoint just before the <em>n</em>th instruction after the given
label. For example,</p>
<pre><code class="language-scheme editable">(set-breakpoint gcd-machine 'test-b 4)
</code></pre>
<p>installs a breakpoint in <code>gcd-machine</code> just before the assignment to
register <code>a</code>. When the simulator reaches the breakpoint it should print
the label and the offset of the breakpoint and stop executing
instructions. Alyssa can then use <code>get-register-contents</code> and
<code>set-register-contents!</code> to manipulate the state of the simulated
machine. She should then be able to continue execution by saying</p>
<pre><code class="language-scheme editable">(proceed-machine &lt;`*`machine`*`&gt;)
</code></pre>
<p>She should also be able to remove a specific breakpoint by means of</p>
<pre><code class="language-scheme editable">(cancel-breakpoint &lt;`*`machine`*`&gt; &lt;`*`label`*`&gt; &lt;`*`n`*`&gt;)
</code></pre>
<p>or to remove all breakpoints by means of</p>
<pre><code class="language-scheme editable">(cancel-all-breakpoints &lt;`*`machine`*`&gt;)
</code></pre>
<hr />
<p>^[4]{.small}^](book-Z-H-32.html#call_footnote_Temp_727)
Using the <code>receive</code> procedure here is a way to get
<code>extract-labels</code> to effectively return two values -- <code>labels</code> and
<code>insts</code> -- without explicitly making a compound data structure to hold
them. An alternative implementation, which returns an explicit pair of
values, is</p>
<pre><code class="language-scheme editable">(define (extract-labels text)
  (if (null? text)
      (cons '() '())
      (let ((result (extract-labels (cdr text))))
        (let ((insts (car result)) (labels (cdr result)))
          (let ((next-inst (car text)))
            (if (symbol? next-inst)
                (cons insts
                      (cons (make-label-entry next-inst insts) labels))
                (cons (cons (make-instruction next-inst) insts)
                      labels))))))
</code></pre>
<p>which would be called by <code>assemble</code> as follows:</p>
<pre><code class="language-scheme editable">(define (assemble controller-text machine)
  (let ((result (extract-labels controller-text)))
    (let ((insts (car result)) (labels (cdr result)))
      (update-insts! insts labels machine)
      insts)))
</code></pre>
<p>You can consider our use of
<code>receive</code> as demonstrating an elegant way to return multiple values, or
simply an excuse to show off a programming trick. An argument like
<code>receive</code> that is the next procedure to be invoked is called a
``continuation.'' Recall that we also used continuations to
implement the backtracking control structure in the <code>amb</code> evaluator in
section <a href="book-Z-H-28.html#%_sec_4.3.3">4.3.3</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="5.1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="5.3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="5.1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="5.3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="./highlight.js"></script>
        <script src="./src/languages/scheme.min.js"></script>
        <script src="./biwascheme.min.js"></script>
        <script src="./biwascheme_run_logic.js"></script>


    </div>
    </body>
</html>
