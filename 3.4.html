<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concurrency: Time Is of the Essence - SICP</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./src/styles/docco.min.css">
        <link rel="stylesheet" href="./run_button_style.css">
        <link rel="stylesheet" href="./custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SICP</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="34--concurrency-time-is-of-the-essence"><a class="header" href="#34--concurrency-time-is-of-the-essence"><a href="book-Z-H-4.html#%_toc_%_sec_3.4">3.4  Concurrency: Time Is of the Essence</a></a></h2>
<p>We've seen the power of computational objects with
local state as tools for modeling. Yet, as
section <a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a> warned, this power
extracts a price: the loss of referential transparency, giving rise to a
thicket of questions about sameness and change, and the need to abandon
the substitution model of evaluation in favor of the more intricate
environment model.</p>
<p>The central issue lurking beneath the complexity of
state, sameness, and change is that by introducing assignment we are
forced to admit <em>time</em> into our computational models. Before we
introduced assignment, all our programs were timeless, in the sense that
any expression that has a value always has the same value. In contrast,
recall the example of modeling withdrawals from a bank account and
returning the resulting balance, introduced at the beginning of
section <a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>:</p>
<pre><code class="language-scheme editable">(withdraw 25)
</code></pre>
<p><em><code>75</code></em></p>
<pre><code class="language-scheme editable">(withdraw 25)
</code></pre>
<p><em><code>50</code></em></p>
<p>Here successive evaluations of the same expression yield different
values. This behavior arises from the fact that the execution of
assignment statements (in this case, assignments to the variable
<code>balance</code>) delineates <em>moments in time</em> when values change. The result
of evaluating an expression depends not only on the expression itself,
but also on whether the evaluation occurs before or after these moments.
Building models in terms of computational objects with local state
forces us to confront time as an essential concept in programming.</p>
<p>We can go further in structuring computational models to match our
perception of the physical world. Objects in the world do not change one
at a time in sequence. Rather we perceive them as acting <em>concurrently</em>
-- all at once. So it is often natural to model systems as collections
of computational processes that execute concurrently. Just as we can
make our programs modular by organizing models in terms of objects with
separate local state, it is often appropriate to divide computational
models into parts that evolve separately and concurrently. Even if the
programs are to be executed on a sequential computer, the practice of
writing programs as if they were to be executed concurrently forces the
programmer to avoid inessential timing constraints and thus makes
programs more modular.</p>
<p>In addition to making programs more modular, concurrent computation can
provide a speed advantage over sequential computation. Sequential
computers execute only one operation at a time, so the amount of time it
takes to perform a task is proportional to the total number of
operations
performed.<a href="book-Z-H-23.html#footnote_Temp_405">^[34]{.small}^</a>
However, if it is possible to decompose a problem into pieces that are
relatively independent and need to communicate only rarely, it may be
possible to allocate pieces to separate computing processors, producing
a speed advantage proportional to the number of processors available.</p>
<p>Unfortunately, the complexities introduced by assignment become even
more problematic in the presence of concurrency. The fact of concurrent
execution, either because the world operates in parallel or because our
computers do, entails additional complexity in our understanding of
time.</p>
<h3 id="341--the-nature-of-time-in-concurrent-systems"><a class="header" href="#341--the-nature-of-time-in-concurrent-systems"><a href="book-Z-H-4.html#%_toc_%_sec_3.4.1">3.4.1  The Nature of Time in Concurrent Systems</a></a></h3>
<p>On the surface, time seems straightforward. It is an
ordering imposed on
events.<a href="book-Z-H-23.html#footnote_Temp_406">^[35]{.small}^</a>
For any events <em>A</em> and <em>B</em>, either <em>A</em> occurs before <em>B</em>, <em>A</em> and <em>B</em>
are simultaneous, or <em>A</em> occurs after <em>B</em>. For instance, returning to
the bank account example, suppose that Peter withdraws $10 and Paul
withdraws $25 from a joint account that initially
contains $100, leaving $65 in the account. Depending on the order of
the two withdrawals, the sequence of balances in the account is either
$100 <img src="book-Z-G-D-15.gif" alt="" /> $90
<img src="book-Z-G-D-15.gif" alt="" /> $65 or $100
<img src="book-Z-G-D-15.gif" alt="" /> $75
<img src="book-Z-G-D-15.gif" alt="" /> $65. In a computer implementation of
the banking system, this changing sequence of balances could be modeled
by successive assignments to a variable <code>balance</code>.</p>
<p>In complex situations, however, such a view can be problematic. Suppose
that Peter and Paul, and other people besides, are accessing the same
bank account through a network of banking machines distributed all over
the world. The actual sequence of balances in the account will depend
critically on the detailed timing of the accesses and the details of the
communication among the machines.</p>
<p>This indeterminacy in the order of events can pose
serious problems in the design of concurrent systems. For instance,
suppose that the withdrawals made by Peter and Paul are implemented as
two separate processes sharing a common variable <code>balance</code>, each process
specified by the procedure given in
section <a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>:</p>
<pre><code class="language-scheme editable">(define (withdraw amount)
  (if (&gt;= balance amount)
      (begin (set! balance (- balance amount))
             balance)
      "Insufficient funds"))
</code></pre>
<p>If the two processes operate independently, then Peter might test the
balance and attempt to withdraw a legitimate amount. However, Paul might
withdraw some funds in between the time that Peter checks the balance
and the time Peter completes the withdrawal, thus invalidating Peter's
test.</p>
<p>Things can be worse still. Consider the expression</p>
<pre><code class="language-scheme editable">(set! balance (- balance amount))
</code></pre>
<p>executed as part of each withdrawal process. This consists of three
steps: (1) accessing the value of the <code>balance</code> variable; (2) computing
the new balance; (3) setting <code>balance</code> to this new value. If Peter and
Paul's withdrawals execute this statement concurrently, then the two
withdrawals might interleave the order in which they access <code>balance</code>
and set it to the new value.</p>
<p>The timing diagram in figure <a href="book-Z-H-23.html#%_fig_3.29">3.29</a> depicts
an order of events where <code>balance</code> starts at 100, Peter withdraws 10,
Paul withdraws 25, and yet the final value of <code>balance</code> is 75. As shown
in the diagram, the reason for this anomaly is that Paul's assignment
of 75 to <code>balance</code> is made under the assumption that the value of
<code>balance</code> to be decremented is 100. That assumption, however, became
invalid when Peter changed <code>balance</code> to 90. This is a catastrophic
failure for the banking system, because the total amount of money in the
system is not conserved. Before the transactions, the total amount of
money was $100. Afterwards, Peter has $10, Paul has $25, and the bank
has
$75.<a href="book-Z-H-23.html#footnote_Temp_407">^[36]{.small}^</a></p>
<p>The general phenomenon illustrated here is
that several processes may share a common state variable. What makes
this complicated is that more than one process may be trying to
manipulate the shared state at the same time. For the bank account
example, during each transaction, each customer should be able to act as
if the other customers did not exist. When a customer changes the
balance in a way that depends on the balance, he must be able to assume
that, just before the moment of change, the balance is still what he
thought it was.</p>
<h4 id="correct-behavior-of-concurrent-programs"><a class="header" href="#correct-behavior-of-concurrent-programs"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_408">Correct behavior of concurrent programs</a></a></h4>
<p>The above example typifies the subtle bugs that can
creep into concurrent programs. The root of this complexity lies in the
assignments to variables that are shared among the different processes.
We already know that we must be careful in writing programs that use
<code>set!</code>, because the results of a computation depend on the order in
which the assignments
occur.<a href="book-Z-H-23.html#footnote_Temp_409">^[37]{.small}^</a>
With concurrent processes we must be especially careful about
assignments, because we may not be able to control the order of the
assignments made by the different processes. If several such changes
might be made concurrently (as with two depositors accessing a joint
account) we need some way to ensure that our system behaves correctly.
For example, in the case of withdrawals from a joint bank account, we
must ensure that money is conserved. To make concurrent programs behave
correctly, we may have to place some restrictions on concurrent
execution.</p>
<p><img src="ch3-Z-G-31.gif" alt="" /></p>
<p><strong>Figure 3.29:</strong>  Timing diagram showing how interleaving the order of
events in two banking withdrawals can lead to an incorrect final
balance.</p>
<p>One possible restriction on concurrency would stipulate that no two
operations that change any shared state variables can occur at the same
time. This is an extremely stringent requirement. For distributed
banking, it would require the system designer to ensure that only one
transaction could proceed at a time. This would be both inefficient and
overly conservative. Figure <a href="book-Z-H-23.html#%_fig_3.30">3.30</a> shows
Peter and Paul sharing a bank account, where Paul has a private account
as well. The diagram illustrates two withdrawals from the shared account
(one by Peter and one by Paul) and a deposit to Paul's private
account.<a href="book-Z-H-23.html#footnote_Temp_410">^[38]{.small}^</a>
The two withdrawals from the shared account must not be concurrent
(since both access and update the same account), and Paul's deposit and
withdrawal must not be concurrent (since both access and update the
amount in Paul's wallet). But there should be no problem permitting
Paul's deposit to his private account to proceed concurrently with
Peter's withdrawal from the shared account.</p>
<p><img src="ch3-Z-G-32.gif" alt="" /></p>
<p><strong>Figure 3.30:</strong>  Concurrent deposits and withdrawals from a joint
account in Bank1 and a private account in Bank2.</p>
<p>A less stringent restriction on concurrency would ensure that a
concurrent system produces the same result as if the processes had run
sequentially in some order. There are two important aspects to this
requirement. First, it does not require the processes to actually run
sequentially, but only to produce results that are the same <em>as if</em> they
had run sequentially. For the example in
figure <a href="book-Z-H-23.html#%_fig_3.30">3.30</a>, the designer of the bank
account system can safely allow Paul's deposit and Peter's withdrawal
to happen concurrently, because the net result will be the same as if
the two operations had happened sequentially. Second, there may be more
than one possible ``correct'' result produced by a concurrent
program, because we require only that the result be the same as for
<em>some</em> sequential order. For example, suppose that Peter and Paul's
joint account starts out with $100, and Peter deposits $40 while Paul
concurrently withdraws half the money in the account. Then sequential
execution could result in the account balance being either $70 or $90
(see
exercise <a href="book-Z-H-23.html#%_thm_3.38">3.38</a>).^[39]{.small}^](book-Z-H-23.html#footnote_Temp_411)</p>
<p>There are still weaker requirements for correct execution of concurrent
programs. A program for simulating diffusion (say, the
flow of heat in an object) might consist of a large number of processes,
each one representing a small volume of space, that update their values
concurrently. Each process repeatedly changes its value to the average
of its own value and its neighbors' values. This algorithm converges to
the right answer independent of the order in which the operations are
done; there is no need for any restrictions on concurrent use of the
shared values.</p>
<p><strong>Exercise 3.38.</strong>  Suppose that Peter, Paul, and Mary
share a joint bank account that initially contains $100. Concurrently,
Peter deposits $10, Paul withdraws $20, and Mary withdraws half the
money in the account, by executing the following commands:</p>
<hr />
<p>Peter:   <code>(set! balance (+ balance 10))</code>
Paul:    <code>(set! balance (- balance 20))</code>
Mary:    <code>(set! balance (- balance (/ balance 2)))</code></p>
<hr />
<p>a. List all the different possible values for <code>balance</code> after these
three transactions have been completed, assuming that the banking system
forces the three processes to run sequentially in some order.</p>
<p>b. What are some other values that could be produced if the system
allows the processes to be interleaved? Draw timing diagrams like the
one in figure <a href="book-Z-H-23.html#%_fig_3.29">3.29</a> to explain how these
values can occur.</p>
<h3 id="342--mechanisms-for-controlling-concurrency"><a class="header" href="#342--mechanisms-for-controlling-concurrency"><a href="book-Z-H-4.html#%_toc_%_sec_3.4.2">3.4.2  Mechanisms for Controlling Concurrency</a></a></h3>
<p>We've seen that the difficulty in dealing with
concurrent processes is rooted in the need to consider the interleaving
of the order of events in the different processes. For example, suppose
we have two processes, one with three ordered events (<em>a</em>,<em>b</em>,<em>c</em>) and
one with three ordered events (<em>x</em>,<em>y</em>,<em>z</em>). If the two processes run
concurrently, with no constraints on how their execution is interleaved,
then there are 20 different possible orderings for the events that are
consistent with the individual orderings for the two processes:</p>
<p><img src="ch3-Z-G-33.gif" alt="" /></p>
<p>As programmers designing this system, we would have to consider the
effects of each of these 20 orderings and check that each behavior is
acceptable. Such an approach rapidly becomes unwieldy as the numbers of
processes and events increase.</p>
<p>A more practical approach to the design of concurrent systems is to
devise general mechanisms that allow us to constrain the interleaving of
concurrent processes so that we can be sure that the program behavior is
correct. Many mechanisms have been developed for this purpose. In this
section, we describe one of them, the <em>serializer</em>.</p>
<h4 id="serializing-access-to-shared-state"><a class="header" href="#serializing-access-to-shared-state"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_413">Serializing access to shared state</a></a></h4>
<p>Serialization implements the following idea: Processes
will execute concurrently, but there will be certain collections of
procedures that cannot be executed concurrently. More precisely,
serialization creates distinguished sets of procedures such that only
one execution of a procedure in each serialized set is permitted to
happen at a time. If some procedure in the set is being executed, then a
process that attempts to execute any procedure in the set will be forced
to wait until the first execution has finished.</p>
<p>We can use serialization to control access to shared variables. For
example, if we want to update a shared variable based on the previous
value of that variable, we put the access to the previous value of the
variable and the assignment of the new value to the variable in the same
procedure. We then ensure that no other procedure that assigns to the
variable can run concurrently with this procedure by serializing all of
these procedures with the same serializer. This guarantees that the
value of the variable cannot be changed between an access and the
corresponding assignment.</p>
<h4 id="serializers-in-scheme"><a class="header" href="#serializers-in-scheme"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_414">Serializers in Scheme</a></a></h4>
<p>To make the above mechanism more concrete, suppose that we have extended
Scheme to include a procedure called <code>parallel-execute</code>:</p>
<pre><code class="language-scheme editable">(parallel-execute &lt;p~1~&gt; &lt;p~2~&gt; ... &lt;p~k~&gt;)
</code></pre>
<p>Each &lt;<em>p</em>&gt; must be a procedure of no arguments. <code>Parallel-execute</code>
creates a separate process for each &lt;<em>p</em>&gt;, which applies &lt;<em>p</em>&gt; (to
no arguments). These processes all run
concurrently.<a href="book-Z-H-23.html#footnote_Temp_415">^[40]{.small}^</a></p>
<p>As an example of how this is used, consider</p>
<pre><code class="language-scheme editable">(define x 10)

(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (+ x 1))))
</code></pre>
<p>This creates two concurrent processes -- <em>P</em><del>1</del>, which sets <code>x</code> to <code>x</code>
times <code>x</code>, and <em>P</em><del>2</del>, which increments <code>x</code>. After execution is
complete, <code>x</code> will be left with one of five possible values, depending
on the interleaving of the events of <em>P</em><del>1</del> and <em>P</em><del>2</del>:</p>
<hr />
<p>101:   <em>P</em><del>1</del> sets <code>x</code> to 100 and then <em>P</em><del>2</del> increments <code>x</code> to 101.
121:   <em>P</em><del>2</del> increments <code>x</code> to 11 and then <em>P</em><del>1</del> sets <code>x</code> to <code>x</code> times <code>x</code>.
110:   <em>P</em><del>2</del> changes <code>x</code> from 10 to 11 between the two times that <em>P</em><del>1</del> accesses the value of <code>x</code> during the evaluation of <code>(* x x)</code>.
11:    <em>P</em><del>2</del> accesses <code>x</code>, then <em>P</em><del>1</del> sets <code>x</code> to 100, then <em>P</em><del>2</del> sets <code>x</code>.
100:   <em>P</em><del>1</del> accesses <code>x</code> (twice), then <em>P</em><del>2</del> sets <code>x</code> to 11, then <em>P</em><del>1</del> sets <code>x</code>.</p>
<hr />
<p>We can constrain the concurrency by using serialized procedures, which
are created by <em>serializers</em>. Serializers are constructed by
<code>make-serializer</code>, whose implementation is given below. A serializer
takes a procedure as argument and returns a serialized procedure that
behaves like the original procedure. All calls to a given serializer
return serialized procedures in the same set.</p>
<p>Thus, in contrast to the example above, executing</p>
<pre><code class="language-scheme editable">(define x 10)

(define s (make-serializer))

(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (+ x 1)))))
</code></pre>
<p>can produce only two possible values for <code>x</code>, 101 or 121. The other
possibilities are eliminated, because the execution of <em>P</em><del>1</del> and <em>P</em><del>2</del>
cannot be interleaved.</p>
<p>Here is a version of the <code>make-account</code> procedure from
section <a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>, where the deposits and
withdrawals have been serialized:</p>
<pre><code class="language-scheme editable">(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance) balance)
            (else (error "Unknown request -- MAKE-ACCOUNT"
                         m))))
    dispatch))
</code></pre>
<p>With this implementation, two processes cannot be withdrawing from or
depositing into a single account concurrently. This eliminates the
source of the error illustrated in
figure <a href="book-Z-H-23.html#%_fig_3.29">3.29</a>, where Peter changes the
account balance between the times when Paul accesses the balance to
compute the new value and when Paul actually performs the assignment. On
the other hand, each account has its own serializer, so that deposits
and withdrawals for different accounts can proceed concurrently.</p>
<p><strong>Exercise 3.39.</strong>  Which of the five possibilities in
the parallel execution shown above remain if we instead serialize
execution as follows:</p>
<pre><code class="language-scheme editable">(define x 10)

(define s (make-serializer))

(parallel-execute (lambda () (set! x ((s (lambda () (* x x))))))
                  (s (lambda () (set! x (+ x 1)))))
</code></pre>
<p><strong>Exercise 3.40.</strong>  Give all possible values of <code>x</code> that
can result from executing</p>
<pre><code class="language-scheme editable">(define x 10)

(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (* x x x))))
</code></pre>
<p>Which of these possibilities remain if we instead use serialized
procedures:</p>
<pre><code class="language-scheme editable">(define x 10)

(define s (make-serializer))

(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (* x x x)))))
</code></pre>
<p><strong>Exercise 3.41.</strong>  Ben Bitdiddle worries that it would
be better to implement the bank account as follows (where the commented
line has been changed):</p>
<pre><code class="language-scheme editable">(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  ;; continued on next page
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance)
             ((protected (lambda () balance)))) ; serialized
            (else (error "Unknown request -- MAKE-ACCOUNT"
                         m))))
    dispatch))
</code></pre>
<p>because allowing unserialized access to the bank balance can result in
anomalous behavior. Do you agree? Is there any scenario that
demonstrates Ben's concern?</p>
<p><strong>Exercise 3.42.</strong>  Ben Bitdiddle suggests that it's a
waste of time to create a new serialized procedure in response to every
<code>withdraw</code> and <code>deposit</code> message. He says that <code>make-account</code> could be
changed so that the calls to <code>protected</code> are done outside the <code>dispatch</code>
procedure. That is, an account would return the same serialized
procedure (which was created at the same time as the account) each time
it is asked for a withdrawal procedure.</p>
<pre><code class="language-scheme editable">(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (let ((protected-withdraw (protected withdraw))
          (protected-deposit (protected deposit)))
      (define (dispatch m)
        (cond ((eq? m 'withdraw) protected-withdraw)
              ((eq? m 'deposit) protected-deposit)
              ((eq? m 'balance) balance)
              (else (error "Unknown request -- MAKE-ACCOUNT"
                           m))))
      dispatch)))
</code></pre>
<p>Is this a safe change to make? In particular, is there any difference in
what concurrency is allowed by these two versions of <code>make-account</code> ?</p>
<h4 id="complexity-of-using-multiple-shared-resources"><a class="header" href="#complexity-of-using-multiple-shared-resources"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_420">Complexity of using multiple shared resources</a></a></h4>
<p>Serializers provide a powerful
abstraction that helps isolate the complexities of concurrent programs
so that they can be dealt with carefully and (hopefully) correctly.
However, while using serializers is relatively straightforward when
there is only a single shared resource (such as a single bank account),
concurrent programming can be treacherously difficult when there are
multiple shared resources.</p>
<p>To illustrate one of the difficulties that can arise, suppose we wish to
swap the balances in two bank accounts. We access each account to find
the balance, compute the difference between the balances, withdraw this
difference from one account, and deposit it in the other account. We
could implement this as
follows:<a href="book-Z-H-23.html#footnote_Temp_421">^[41]{.small}^</a></p>
<pre><code class="language-scheme editable">(define (exchange account1 account2)
  (let ((difference (- (account1 'balance)
                       (account2 'balance))))
    ((account1 'withdraw) difference)
    ((account2 'deposit) difference)))
</code></pre>
<p>This procedure works well when only a single process is trying to do the
exchange. Suppose, however, that Peter and Paul both have access to
accounts <em>a</em>1, <em>a</em>2, and <em>a</em>3, and that Peter exchanges <em>a</em>1 and <em>a</em>2
while Paul concurrently exchanges <em>a</em>1 and <em>a</em>3. Even with account
deposits and withdrawals serialized for individual accounts (as in the
<code>make-account</code> procedure shown above in this section), <code>exchange</code> can
still produce incorrect results. For example, Peter might compute the
difference in the balances for <em>a</em>1 and <em>a</em>2, but then Paul might change
the balance in <em>a</em>1 before Peter is able to complete the
exchange.<a href="book-Z-H-23.html#footnote_Temp_422">^[42]{.small}^</a>
For correct behavior, we must arrange for the <code>exchange</code> procedure to
lock out any other concurrent accesses to the accounts during the entire
time of the exchange.</p>
<p>One way we can accomplish this is by using both accounts' serializers
to serialize the entire <code>exchange</code> procedure. To do this, we will
arrange for access to an account's serializer. Note that we are
deliberately breaking the modularity of the bank-account object by
exposing the serializer. The following version of <code>make-account</code> is
identical to the original version given in
section <a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>, except that a serializer
is provided to protect the balance variable, and the serializer is
exported via message passing:</p>
<pre><code class="language-scheme editable">(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error "Unknown request -- MAKE-ACCOUNT"
                         m))))
    dispatch))
</code></pre>
<p>We can use this to do serialized deposits and withdrawals. However,
unlike our earlier serialized account, it is now the responsibility of
each user of bank-account objects to explicitly manage the
serialization, for example as
follows:<a href="book-Z-H-23.html#footnote_Temp_423">^[43]{.small}^</a></p>
<pre><code class="language-scheme editable">(define (deposit account amount)
  (let ((s (account 'serializer))
        (d (account 'deposit)))
    ((s d) amount)))
</code></pre>
<p>Exporting the serializer in this way gives us enough flexibility to
implement a serialized exchange program. We simply serialize the
original <code>exchange</code> procedure with the serializers for both accounts:</p>
<pre><code class="language-scheme editable">(define (serialized-exchange account1 account2)
  (let ((serializer1 (account1 'serializer))
        (serializer2 (account2 'serializer)))
    ((serializer1 (serializer2 exchange))
     account1
     account2)))
</code></pre>
<p><strong>Exercise 3.43.</strong>  Suppose that the balances in three
accounts start out as $10, $20, and $30, and that multiple processes
run, exchanging the balances in the accounts. Argue that if the
processes are run sequentially, after any number of concurrent
exchanges, the account balances should be $10, $20, and $30 in some
order. Draw a timing diagram like the one in
figure <a href="book-Z-H-23.html#%_fig_3.29">3.29</a> to show how this condition
can be violated if the exchanges are implemented using the first version
of the account-exchange program in this section. On the other hand,
argue that even with this <code>exchange</code> program, the sum of the balances in
the accounts will be preserved. Draw a timing diagram to show how even
this condition would be violated if we did not serialize the
transactions on individual accounts.</p>
<p><strong>Exercise 3.44.</strong>  Consider the problem
of transferring an amount from one account to another. Ben Bitdiddle
claims that this can be accomplished with the following procedure, even
if there are multiple people concurrently transferring money among
multiple accounts, using any account mechanism that serializes deposit
and withdrawal transactions, for example, the version of <code>make-account</code>
in the text above.</p>
<pre><code class="language-scheme editable">(define (transfer from-account to-account amount)
  ((from-account 'withdraw) amount)
  ((to-account 'deposit) amount))
</code></pre>
<p>Louis Reasoner claims that there is a problem here, and that we need to
use a more sophisticated method, such as the one required for dealing
with the exchange problem. Is Louis right? If not, what is the essential
difference between the transfer problem and the exchange problem? (You
should assume that the balance in <code>from-account</code> is at least <code>amount</code>.)</p>
<p><strong>Exercise 3.45.</strong>  Louis Reasoner thinks our
bank-account system is unnecessarily complex and error-prone now that
deposits and withdrawals aren't automatically serialized. He suggests
that <code>make-account-and-serializer</code> should have exported the serializer
(for use by such procedures as <code>serialized-exchange</code>) in addition to
(rather than instead of) using it to serialize accounts and deposits as
<code>make-account</code> did. He proposes to redefine accounts as follows:</p>
<pre><code class="language-scheme editable">(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (balance-serializer withdraw))
            ((eq? m 'deposit) (balance-serializer deposit))
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error "Unknown request -- MAKE-ACCOUNT"
                         m))))
    dispatch))
</code></pre>
<p>Then deposits are handled as with the original <code>make-account</code>:</p>
<pre><code class="language-scheme editable">(define (deposit account amount)
  ((account 'deposit) amount))
</code></pre>
<p>Explain what is wrong with Louis's reasoning. In particular, consider
what happens when <code>serialized-exchange</code> is called.</p>
<h4 id="implementing-serializers"><a class="header" href="#implementing-serializers"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_427">Implementing serializers</a></a></h4>
<p>We implement serializers in terms of a more primitive
synchronization mechanism called a <em>mutex</em>. A mutex is an
object that supports two operations -- the mutex can be
<em>acquired</em>, and the mutex can be
<em>released</em>. Once a mutex has been acquired, no other
acquire operations on that mutex may proceed until the mutex is
released.<a href="book-Z-H-23.html#footnote_Temp_428">^[44]{.small}^</a>
In our implementation, each serializer has an associated mutex. Given a
procedure <code>p</code>, the serializer returns a procedure that acquires the
mutex, runs <code>p</code>, and then releases the mutex. This ensures that only one
of the procedures produced by the serializer can be running at once,
which is precisely the serialization property that we need to guarantee.</p>
<pre><code class="language-scheme editable">(define (make-serializer)
  (let ((mutex (make-mutex)))
    (lambda (p)
      (define (serialized-p . args)
        (mutex 'acquire)
        (let ((val (apply p args)))
          (mutex 'release)
          val))
      serialized-p)))
</code></pre>
<p>The mutex is a mutable object (here we'll use a one-element list, which
we'll refer to as a <em>cell</em>) that can hold the value true
or false. When the value is false, the mutex is available to be
acquired. When the value is true, the mutex is unavailable, and any
process that attempts to acquire the mutex must wait.</p>
<p>Our mutex constructor <code>make-mutex</code> begins by initializing the cell
contents to false. To acquire the mutex, we test the cell. If the mutex
is available, we set the cell contents to true and proceed. Otherwise,
we wait in a loop, attempting to acquire over and over again, until we
find that the mutex is
available.<a href="book-Z-H-23.html#footnote_Temp_429">^[45]{.small}^</a>
To release the mutex, we set the cell contents to false.</p>
<pre><code class="language-scheme editable">(define (make-mutex)
  (let ((cell (list false)))           
    (define (the-mutex m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell)
                 (the-mutex 'acquire))) ; retry
            ((eq? m 'release) (clear! cell))))
    the-mutex))
(define (clear! cell)
  (set-car! cell false))
</code></pre>
<p><code>Test-and-set!</code> tests the cell and returns the result of the test. In
addition, if the test was false, <code>test-and-set!</code> sets the cell contents
to true before returning false. We can express this behavior as the
following procedure:</p>
<pre><code class="language-scheme editable">(define (test-and-set! cell)
  (if (car cell)
      true
      (begin (set-car! cell true)
             false)))
</code></pre>
<p>However, this implementation of <code>test-and-set!</code> does not suffice as it
stands. There is a crucial subtlety here, which is the essential place
where concurrency control enters the system: The <code>test-and-set!</code>
operation must be performed <em>atomically</em>. That is, we
must guarantee that, once a process has tested the cell and found it to
be false, the cell contents will actually be set to true before any
other process can test the cell. If we do not make this guarantee, then
the mutex can fail in a way similar to the bank-account failure in
figure <a href="book-Z-H-23.html#%_fig_3.29">3.29</a>. (See
exercise <a href="book-Z-H-23.html#%_thm_3.46">3.46</a>.)</p>
<p>The actual implementation of <code>test-and-set!</code> depends on the details of
how our system runs concurrent processes. For example, we might be
executing concurrent processes on a sequential processor using a
time-slicing mechanism that cycles through the processes,
permitting each process to run for a short time before interrupting it
and moving on to the next process. In that case, <code>test-and-set!</code> can
work by disabling time slicing during the testing and
setting.<a href="book-Z-H-23.html#footnote_Temp_430">^[46]{.small}^</a>
Alternatively, multiprocessing computers provide instructions that
support atomic operations directly in
hardware.<a href="book-Z-H-23.html#footnote_Temp_431">^[47]{.small}^</a></p>
<p><strong>Exercise 3.46.</strong>  Suppose that we implement
<code>test-and-set!</code> using an ordinary procedure as shown in the text,
without attempting to make the operation atomic. Draw a timing diagram
like the one in figure <a href="book-Z-H-23.html#%_fig_3.29">3.29</a> to
demonstrate how the mutex implementation can fail by allowing two
processes to acquire the mutex at the same time.</p>
<p><strong>Exercise 3.47.</strong>  A semaphore (of size
<em>n</em>) is a generalization of a mutex. Like a mutex, a semaphore supports
acquire and release operations, but it is more general in that up to <em>n</em>
processes can acquire it concurrently. Additional processes that attempt
to acquire the semaphore must wait for release operations. Give
implementations of semaphores</p>
<p>a. in terms of mutexes</p>
<p>b. in terms of atomic <code>test-and-set!</code> operations.</p>
<h4 id="deadlock"><a class="header" href="#deadlock"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_434">Deadlock</a></a></h4>
<p>Now that we have seen how to implement
serializers, we can see that account exchanging still has a problem,
even with the <code>serialized-exchange</code> procedure above. Imagine that Peter
attempts to exchange <em>a</em>1 with <em>a</em>2 while Paul concurrently attempts to
exchange <em>a</em>2 with <em>a</em>1. Suppose that Peter's process reaches the point
where it has entered a serialized procedure protecting <em>a</em>1 and, just
after that, Paul's process enters a serialized procedure protecting
<em>a</em>2. Now Peter cannot proceed (to enter a serialized procedure
protecting <em>a</em>2) until Paul exits the serialized procedure protecting
<em>a</em>2. Similarly, Paul cannot proceed until Peter exits the serialized
procedure protecting <em>a</em>1. Each process is stalled forever, waiting for
the other. This situation is called a <em>deadlock</em>. Deadlock is always a
danger in systems that provide concurrent access to multiple shared
resources.</p>
<p>One way to avoid the deadlock in this situation is to
give each account a unique identification number and rewrite
<code>serialized-exchange</code> so that a process will always attempt to enter a
procedure protecting the lowest-numbered account first. Although this
method works well for the exchange problem, there are other situations
that require more sophisticated deadlock-avoidance techniques, or where
deadlock cannot be avoided at all. (See
exercises <a href="book-Z-H-23.html#%_thm_3.48">3.48</a>
and <a href="book-Z-H-23.html#%_thm_3.49">3.49</a>.)<a href="book-Z-H-23.html#footnote_Temp_435">^[48]{.small}^</a></p>
<p><strong>Exercise 3.48.</strong>  Explain in detail why
the deadlock-avoidance method described above, (i.e., the accounts are
numbered, and each process attempts to acquire the smaller-numbered
account first) avoids deadlock in the exchange problem. Rewrite
<code>serialized-exchange</code> to incorporate this idea. (You will also need to
modify <code>make-account</code> so that each account is created with a number,
which can be accessed by sending an appropriate message.)</p>
<p><strong>Exercise 3.49.</strong>  Give a scenario where the
deadlock-avoidance mechanism described above does not work. (Hint: In
the exchange problem, each process knows in advance which accounts it
will need to get access to. Consider a situation where a process must
get access to some shared resources before it can know which additional
shared resources it will require.)</p>
<h4 id="concurrency-time-and-communication"><a class="header" href="#concurrency-time-and-communication"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_438">Concurrency, time, and communication</a></a></h4>
<p>We've seen how programming concurrent systems requires controlling the
ordering of events when different processes access shared state, and
we've seen how to achieve this control through judicious use of
serializers. But the problems of concurrency lie deeper than this,
because, from a fundamental point of view, it's not always clear what
is meant by ``shared state.''</p>
<p>Mechanisms such as <code>test-and-set!</code> require processes to examine a global
shared flag at arbitrary times. This is problematic and inefficient to
implement in modern high-speed processors, where due to optimization
techniques such as pipelining and cached memory, the contents of memory
may not be in a consistent state at every instant. In contemporary
multiprocessing systems, therefore, the serializer paradigm is being
supplanted by new approaches to concurrency
control.<a href="book-Z-H-23.html#footnote_Temp_439">^[49]{.small}^</a></p>
<p>The problematic aspects of shared state also arise in large, distributed
systems. For instance, imagine a distributed banking system where
individual branch banks maintain local values for bank balances and
periodically compare these with values maintained by other branches. In
such a system the value of ``the account balance'' would be
undetermined, except right after synchronization. If Peter deposits
money in an account he holds jointly with Paul, when should we say that
the account balance has changed -- when the balance in the local branch
changes, or not until after the synchronization? And if Paul accesses
the account from a different branch, what are the reasonable constraints
to place on the banking system such that the behavior is
``correct''? The only thing that might matter for correctness is the
behavior observed by Peter and Paul individually and the ``state''
of the account immediately after synchronization. Questions about the
``real'' account balance or the order of events between
synchronizations may be irrelevant or
meaningless.<a href="book-Z-H-23.html#footnote_Temp_440">^[50]{.small}^</a></p>
<p>The basic phenomenon here is that synchronizing different
processes, establishing shared state, or imposing an order on events
requires communication among the processes. In essence, any notion of
time in concurrency control must be intimately tied to
communication.<a href="book-Z-H-23.html#footnote_Temp_441">^[51]{.small}^</a>
It is intriguing that a similar connection between time and
communication also arises in the Theory of Relativity,
where the speed of light (the fastest signal that can be used to
synchronize events) is a fundamental constant relating time and space.
The complexities we encounter in dealing with time and state in our
computational models may in fact mirror a fundamental complexity of the
physical universe.</p>
<hr />
<p>^[34]{.small}^](book-Z-H-23.html#call_footnote_Temp_405)
Most real processors actually execute a few operations at a time,
following a strategy called <em>pipelining</em>. Although this
technique greatly improves the effective utilization of the hardware, it
is used only to speed up the execution of a sequential instruction
stream, while retaining the behavior of the sequential program.</p>
<p>^[35]{.small}^](book-Z-H-23.html#call_footnote_Temp_406)
To quote some graffiti seen on a Cambridge building wall:
``Time is a device that was invented to keep everything from happening
at once.''</p>
<p>^[36]{.small}^](book-Z-H-23.html#call_footnote_Temp_407)
An even worse failure for this system could occur if the two <code>set!</code>
operations attempt to change the balance simultaneously, in which case
the actual data appearing in memory might end up being a random
combination of the information being written by the two processes. Most
computers have interlocks on the primitive memory-write operations,
which protect against such simultaneous access. Even this seemingly
simple kind of protection, however, raises implementation challenges in
the design of multiprocessing computers, where elaborate
<em>cache-coherence</em> protocols are required to ensure that
the various processors will maintain a consistent view of memory
contents, despite the fact that data may be replicated (``cached'')
among the different processors to increase the speed of memory access.</p>
<p>^[37]{.small}^](book-Z-H-23.html#call_footnote_Temp_409)
The factorial program in section <a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a>
illustrates this for a single sequential process.</p>
<p>^[38]{.small}^](book-Z-H-23.html#call_footnote_Temp_410)
The columns show the contents of Peter's wallet, the joint account (in
Bank1), Paul's wallet, and Paul's private account (in Bank2), before
and after each withdrawal (W) and deposit (D). Peter withdraws $10 from
Bank1; Paul deposits $5 in Bank2, then withdraws $25 from Bank1.</p>
<p>^[39]{.small}^](book-Z-H-23.html#call_footnote_Temp_411)
A more formal way to express this idea is to say that concurrent
programs are inherently <em>nondeterministic</em>. That is, they
are described not by single-valued functions, but by functions whose
results are sets of possible values. In
section <a href="book-Z-H-28.html#%_sec_4.3">4.3</a> we will study a language for
expressing nondeterministic computations.</p>
<p>^[40]{.small}^](book-Z-H-23.html#call_footnote_Temp_415)
<code>Parallel-execute</code> is not part of standard Scheme, but it can be
implemented in MIT Scheme. In our implementation, the new concurrent
processes also run concurrently with the original Scheme process. Also,
in our implementation, the value returned by <code>parallel-execute</code> is a
special control object that can be used to halt the newly created
processes.</p>
<p>^[41]{.small}^](book-Z-H-23.html#call_footnote_Temp_421)
We have simplified <code>exchange</code> by exploiting the fact that our <code>deposit</code>
message accepts negative amounts. (This is a serious bug in our banking
system!)</p>
<p>^[42]{.small}^](book-Z-H-23.html#call_footnote_Temp_422)
If the account balances start out as $10, $20, and $30, then after
any number of concurrent exchanges, the balances should still be $10,
$20, and $30 in some order. Serializing the deposits to individual
accounts is not sufficient to guarantee this. See
exercise <a href="book-Z-H-23.html#%_thm_3.43">3.43</a>.</p>
<p>^[43]{.small}^](book-Z-H-23.html#call_footnote_Temp_423)
Exercise <a href="book-Z-H-23.html#%_thm_3.45">3.45</a> investigates why deposits
and withdrawals are no longer automatically serialized by the account.</p>
<p>^[44]{.small}^](book-Z-H-23.html#call_footnote_Temp_428)
The term ``mutex'' is an abbreviation for <em>mutual
exclusion</em>. The general problem of arranging a mechanism that permits
concurrent processes to safely share resources is called the mutual
exclusion problem. Our mutex is a simple variant of the
<em>semaphore</em> mechanism (see
exercise <a href="book-Z-H-23.html#%_thm_3.47">3.47</a>), which was introduced in
the ``THE'' Multiprogramming System developed at the
Technological University of Eindhoven and named for the
university's initials in Dutch (Dijkstra 1968a). The acquire and
release operations were originally called
P and V, from the Dutch
words <em>passeren</em> (to pass) and <em>vrijgeven</em> (to release), in reference to
the semaphores used on railroad systems. Dijkstra's classic exposition
(1968b) was one of the first to clearly present the issues of
concurrency control, and showed how to use semaphores to handle a
variety of concurrency problems.</p>
<p>^[45]{.small}^](book-Z-H-23.html#call_footnote_Temp_429)
In most time-shared operating systems, processes that are
blocked by a mutex do not waste time
``busy-waiting'' as above. Instead, the system schedules another
process to run while the first is waiting, and the blocked process is
awakened when the mutex becomes available.</p>
<p>^[46]{.small}^](book-Z-H-23.html#call_footnote_Temp_430)
In MIT Scheme for a single processor, which uses a time-slicing model,
<code>test-and-set!</code> can be implemented as follows:</p>
<pre><code class="language-scheme editable">(define (test-and-set! cell)
  (without-interrupts
   (lambda ()
     (if (car cell)
         true
         (begin (set-car! cell true)
                false)))))
</code></pre>
<p><code>Without-interrupts</code> disables time-slicing interrupts while its
procedure argument is being executed.</p>
<p>^[47]{.small}^](book-Z-H-23.html#call_footnote_Temp_431)
There are many variants of such instructions --
including test-and-set, test-and-clear, swap, compare-and-exchange,
load-reserve, and store-conditional -- whose design must be carefully
matched to the machine's processor-memory interface. One issue that
arises here is to determine what happens if two processes attempt to
acquire the same resource at exactly the same time by using such an
instruction. This requires some mechanism for making a decision about
which process gets control. Such a mechanism is called an
<em>arbiter</em>. Arbiters usually boil down to some sort of
hardware device. Unfortunately, it is possible to prove that one cannot
physically construct a fair arbiter that works 100% of the time unless
one allows the arbiter an arbitrarily long time to make its decision.
The fundamental phenomenon here was originally observed by the
fourteenth-century French philosopher Jean Buridan in his
commentary on Aristotle's <em>De caelo</em>. Buridan argued
that a perfectly rational dog placed between two equally
attractive sources of food will starve to death, because it is incapable
of deciding which to go to first.</p>
<p>^[48]{.small}^](book-Z-H-23.html#call_footnote_Temp_435)
The general technique for avoiding deadlock by numbering the
shared resources and acquiring them in order is due to
Havender (1968). Situations
where deadlock cannot be avoided require <em>deadlock-recovery</em> methods,
which entail having processes ``back out'' of the deadlocked state
and try again. Deadlock-recovery mechanisms are widely used in database
management systems, a topic that is treated in detail in Gray and Reuter
1993.</p>
<p>^[49]{.small}^](book-Z-H-23.html#call_footnote_Temp_439)
One such alternative to serialization is called <em>barrier
synchronization</em>. The programmer permits concurrent processes to execute
as they please, but establishes certain synchronization points
(``barriers'') through which no process can proceed until all the
processes have reached the barrier. Modern processors provide machine
instructions that permit programmers to establish synchronization points
at places where consistency is required. The PowerPC
^<em>TM</em>^, for example, includes for this purpose two instructions called
SYNC and EIEIO (Enforced In-order
Execution of Input/Output).</p>
<p>^[50]{.small}^](book-Z-H-23.html#call_footnote_Temp_440)
This may seem like a strange point of view, but there are
systems that work this way. International charges to
credit-card accounts, for example, are normally cleared on a per-country
basis, and the charges made in different countries are periodically
reconciled. Thus the account balance may be different in different
countries.</p>
<p>^[51]{.small}^](book-Z-H-23.html#call_footnote_Temp_441)
For distributed systems, this perspective was pursued by
Lamport (1978), who showed how to use communication to
establish ``global clocks'' that can be used to establish orderings
on events in distributed systems.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="3.3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="3.5.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="3.3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="3.5.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="./highlight.js"></script>
        <script src="./src/languages/scheme.min.js"></script>
        <script src="./biwascheme.min.js"></script>
        <script src="./biwascheme_run_logic.js"></script>


    </div>
    </body>
</html>
