<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Storage Allocation and Garbage Collection - SICP</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./src/styles/docco.min.css">
        <link rel="stylesheet" href="./run_button_style.css">
        <link rel="stylesheet" href="./custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SICP</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="53--storage-allocation-and-garbage-collection"><a class="header" href="#53--storage-allocation-and-garbage-collection"><a href="book-Z-H-4.html#%_toc_%_sec_5.3">5.3  Storage Allocation and Garbage Collection</a></a></h2>
<p>In
section <a href="book-Z-H-34.html#%_sec_5.4">5.4</a>, we will show how to implement
a Scheme evaluator as a register machine. In order to simplify the
discussion, we will assume that our register machines can be equipped
with a <em>list-structured memory</em>, in which the basic operations for
manipulating list-structured data are primitive. Postulating the
existence of such a memory is a useful abstraction when one is focusing
on the mechanisms of control in a Scheme interpreter, but this does not
reflect a realistic view of the actual primitive data operations of
contemporary computers. To obtain a more complete picture of how a Lisp
system operates, we must investigate how list structure can be
represented in a way that is compatible with conventional computer
memories.</p>
<p>There are two considerations in implementing list structure. The first
is purely an issue of representation: how to represent the
'box-and-pointer' structure of Lisp pairs, using only the storage
and addressing capabilities of typical computer memories. The second
issue concerns the management of memory as a computation proceeds. The
operation of a Lisp system depends crucially on the ability to
continually create new data objects. These include objects that are
explicitly created by the Lisp procedures being interpreted as well as
structures created by the interpreter itself, such as environments and
argument lists. Although the constant creation of new data objects would
pose no problem on a computer with an infinite amount of rapidly
addressable memory, computer memories are available only in finite sizes
(more's the pity). Lisp systems thus provide an
<em>automatic storage allocation</em> facility to support the
illusion of an infinite memory. When a data object is no longer needed,
the memory allocated to it is automatically recycled and used to
construct new data objects. There are various techniques for providing
such automatic storage allocation. The method we shall discuss in this
section is called <em>garbage collection</em>.</p>
<h3 id="531--memory-as-vectors"><a class="header" href="#531--memory-as-vectors"><a href="book-Z-H-4.html#%_toc_%_sec_5.3.1">5.3.1  Memory as Vectors</a></a></h3>
<p>A conventional computer memory can be thought of as an array of
cubbyholes, each of which can contain a piece of information. Each
cubbyhole has a unique name, called its <em>address</em> or
<em>location</em>. Typical memory systems provide two primitive
operations: one that fetches the data stored in a specified location and
one that assigns new data to a specified location. Memory addresses can
be incremented to support sequential access to some set of the
cubbyholes. More generally, many important data operations require that
memory addresses be treated as data, which can be stored in memory
locations and manipulated in machine registers. The representation of
list structure is one application of such
<em>address arithmetic</em>.</p>
<p>To model computer memory, we use a new kind of data structure called a
<em>vector</em>. Abstractly, a vector is a compound data object
whose individual elements can be accessed by means of an integer index
in an amount of time that is independent of the
index.<a href="book-Z-H-33.html#footnote_Temp_744">^[5]{.small}^</a>
In order to describe memory operations, we use two primitive Scheme
procedures for manipulating vectors:</p>
<ul>
<li></li>
<li>
<p><code>(vector-ref &lt;</code><em><code>vector</code></em><code>&gt; &lt;</code><em><code>n</code></em><code>&gt;)</code> returns the <em>n</em>th element of
the vector.</p>
</li>
<li>
<p><code>(vector-set! &lt;</code><em><code>vector</code></em><code>&gt; &lt;</code><em><code>n</code></em><code>&gt; &lt;</code><em><code>value</code></em><code>&gt;)</code> sets the <em>n</em>th
element of the vector to the designated value.</p>
</li>
</ul>
<p>For example, if <code>v</code> is a vector, then <code>(vector-ref v 5)</code> gets the fifth
entry in the vector <code>v</code> and <code>(vector-set! v 5 7)</code> changes the value of
the fifth entry of the vector <code>v</code> to
7.<a href="book-Z-H-33.html#footnote_Temp_745">^[6]{.small}^</a>
For computer memory, this access can be implemented through the use of
address arithmetic to combine a <em>base address</em> that specifies the
beginning location of a vector in memory with an <em>index</em> that specifies
the offset of a particular element of the vector.</p>
<h4 id="representing-lisp-data"><a class="header" href="#representing-lisp-data"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_746">Representing Lisp data</a></a></h4>
<p>We can use vectors to implement the basic
pair structures required for a list-structured memory. Let us imagine
that computer memory is divided into two vectors:
<code>the-cars</code> and <code>the-cdrs</code>. We will
represent list structure as follows: A pointer to a pair is an index
into the two vectors. The <code>car</code> of the pair is the entry in <code>the-cars</code>
with the designated index, and the <code>cdr</code> of the pair is the entry in
<code>the-cdrs</code> with the designated index. We also need a representation for
objects other than pairs (such as numbers and symbols) and a way to
distinguish one kind of data from another. There are many methods of
accomplishing this, but they all reduce to using
<em>typed pointers</em>, that is, to extending
the notion of 'pointer' to include information on data
type.<a href="book-Z-H-33.html#footnote_Temp_747">^[7]{.small}^</a>
The data type enables the system to distinguish a pointer to a pair
(which consists of the 'pair' data type and an index into the
memory vectors) from pointers to other kinds of data (which consist of
some other data type and whatever is being used to represent data of
that type). Two data objects are considered to be the
same (<code>eq?</code>) if their pointers are
identical.<a href="book-Z-H-33.html#footnote_Temp_748">^[8]{.small}^</a>
Figure <a href="book-Z-H-33.html#%_fig_5.14">5.14</a> illustrates the use of this
method to represent the list <code>((1 2) 3 4)</code>, whose box-and-pointer
diagram is also shown. We use letter prefixes to denote the data-type
information. Thus, a pointer to the pair with index 5 is denoted <code>p5</code>,
the empty list is denoted by the pointer <code>e0</code>, and a pointer to the
number 4 is denoted <code>n4</code>. In the box-and-pointer diagram, we have
indicated at the lower left of each pair the vector index that specifies
where the <code>car</code> and <code>cdr</code> of the pair are stored. The blank locations in
<code>the-cars</code> and <code>the-cdrs</code> may contain parts of other list structures
(not of interest here).</p>
<p><img src="ch5-Z-G-7.gif" alt="" /></p>
<p><strong>Figure 5.14:</strong>  Box-and-pointer and memory-vector representations of
the list <code>((1 2) 3 4)</code>.</p>
<p>A pointer to a number, such as <code>n4</code>, might consist of a type indicating
numeric data together with the actual representation of the number
4.<a href="book-Z-H-33.html#footnote_Temp_749">^[9]{.small}^</a>
To deal with numbers that are too large to be represented in the fixed
amount of space allocated for a single pointer, we could use a distinct
<em>bignum</em> data type, for which the pointer designates a
list in which the parts of the number are
stored.<a href="book-Z-H-33.html#footnote_Temp_750">^[10]{.small}^</a></p>
<p>A symbol might be represented as a typed pointer that
designates a sequence of the characters that form the symbol's printed
representation. This sequence is constructed by the Lisp reader when the
character string is initially encountered in input. Since we want two
instances of a symbol to be recognized as the 'same' symbol by
<code>eq?</code> and we want <code>eq?</code> to be a simple test for equality
of pointers, we must ensure that if the reader sees the same character
string twice, it will use the same pointer (to the same sequence of
characters) to represent both occurrences. To accomplish this, the
reader maintains a table, traditionally called the
<em>obarray</em>, of all the symbols it has ever encountered.
When the reader encounters a character string and is about to construct
a symbol, it checks the obarray to see if it has ever before seen the
same character string. If it has not, it uses the characters to
construct a new symbol (a typed pointer to a new character sequence) and
enters this pointer in the obarray. If the reader has seen the string
before, it returns the symbol pointer stored in the obarray. This
process of replacing character strings by unique pointers is called
<em>interning</em> symbols.</p>
<h4 id="implementing-the-primitive-list-operations"><a class="header" href="#implementing-the-primitive-list-operations"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_751">Implementing the primitive list operations</a></a></h4>
<p>Given the above representation scheme, we
can replace each 'primitive' list operation of a register machine
with one or more primitive vector operations. We will use two registers,
<code>the-cars</code> and <code>the-cdrs</code>, to identify the memory vectors, and will
assume that <code>vector-ref</code> and <code>vector-set!</code> are available as primitive
operations. We also assume that numeric operations on pointers (such as
incrementing a pointer, using a pair pointer to index a vector, or
adding two numbers) use only the index portion of the typed pointer.</p>
<p>For example, we can make a register machine support the instructions</p>
<pre><code class="language-scheme editable">(assign &lt;*reg~1~*&gt; (op car) (reg &lt;*reg~2~*&gt;))

(assign &lt;*reg~1~*&gt; (op cdr) (reg &lt;*reg~2~*&gt;))
</code></pre>
<p>if we implement these, respectively, as</p>
<pre><code class="language-scheme editable">(assign &lt;*reg~1~*&gt; (op vector-ref) (reg the-cars) (reg &lt;*reg~2~*&gt;))

(assign &lt;*reg~1~*&gt; (op vector-ref) (reg the-cdrs) (reg &lt;*reg~2~*&gt;))
</code></pre>
<p>The instructions</p>
<pre><code class="language-scheme editable">(perform (op set-car!) (reg &lt;*reg~1~*&gt;) (reg &lt;*reg~2~*&gt;))

(perform (op set-cdr!) (reg &lt;*reg~1~*&gt;) (reg &lt;*reg~2~*&gt;))
</code></pre>
<p>are implemented as</p>
<pre><code class="language-scheme editable">(perform
 (op vector-set!) (reg the-cars) (reg &lt;*reg~1~*&gt;) (reg &lt;*reg~2~*&gt;))

(perform
 (op vector-set!) (reg the-cdrs) (reg &lt;*reg~1~*&gt;) (reg &lt;*reg~2~*&gt;))
</code></pre>
<p><code>Cons</code> is performed by allocating an unused index and
storing the arguments to <code>cons</code> in <code>the-cars</code> and <code>the-cdrs</code> at that
indexed vector position. We presume that there is a special register,
<code>free</code>, that always holds a pair pointer containing the
next available index, and that we can increment the index part of that
pointer to find the next free
location.<a href="book-Z-H-33.html#footnote_Temp_752">^[11]{.small}^</a>
For example, the instruction</p>
<pre><code class="language-scheme editable">(assign &lt;*reg~1~*&gt; (op cons) (reg &lt;*reg~2~*&gt;) (reg &lt;*reg~3~*&gt;))
</code></pre>
<p>is implemented as the following sequence of vector
operations:<a href="book-Z-H-33.html#footnote_Temp_753">^[12]{.small}^</a></p>
<pre><code class="language-scheme editable">(perform
 (op vector-set!) (reg the-cars) (reg free) (reg &lt;*reg~2~*&gt;))
(perform
 (op vector-set!) (reg the-cdrs) (reg free) (reg &lt;*reg~3~*&gt;))
(assign &lt;*reg~1~*&gt; (reg free))
(assign free (op +) (reg free) (const 1))
</code></pre>
<p>The <code>eq?</code> operation</p>
<pre><code class="language-scheme editable">(op eq?) (reg &lt;*reg~1~*&gt;) (reg &lt;*reg~2~*&gt;)
</code></pre>
<p>simply tests the equality of all fields in the registers, and
predicates
such as <code>pair?</code>, <code>null?</code>, <code>symbol?</code>, and <code>number?</code> need only check the
type field.</p>
<h4 id="implementing-stacks"><a class="header" href="#implementing-stacks"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_754">Implementing stacks</a></a></h4>
<p>Although our register machines use stacks, we need do
nothing special here, since stacks can be modeled in terms of lists. The
stack can be a list of the saved values, pointed to by a special
register <code>the-stack</code>. Thus, <code>(save &lt;</code><em><code>reg</code></em><code>&gt;)</code> can be implemented as</p>
<pre><code class="language-scheme editable">(assign the-stack (op cons) (reg &lt;*reg*&gt;) (reg the-stack))
</code></pre>
<p>Similarly, <code>(restore &lt;</code><em><code>reg</code></em><code>&gt;)</code> can be implemented as</p>
<pre><code class="language-scheme editable">(assign &lt;*reg*&gt; (op car) (reg the-stack))
(assign the-stack (op cdr) (reg the-stack))
</code></pre>
<p>and <code>(perform (op initialize-stack))</code> can be implemented as</p>
<pre><code class="language-scheme editable">(assign the-stack (const ()))
</code></pre>
<p>These operations can be further expanded in terms of the vector
operations given above. In conventional computer architectures, however,
it is usually advantageous to allocate the stack as a separate vector.
Then pushing and popping the stack can be accomplished by incrementing
or decrementing an index into that vector.</p>
<p><strong>Exercise 5.20.</strong>  Draw the box-and-pointer
representation and the memory-vector representation (as in
figure <a href="book-Z-H-33.html#%_fig_5.14">5.14</a>) of the list structure
produced by</p>
<pre><code class="language-scheme editable">(define x (cons 1 2))
(define y (list x x))
</code></pre>
<p>with the <code>free</code> pointer initially <code>p1</code>. What is the final value of
<code>free</code> ? What pointers represent the values of <code>x</code> and <code>y</code> ?</p>
<p><strong>Exercise 5.21.</strong>  Implement register
machines for the following procedures. Assume that the list-structure
memory operations are available as machine primitives.</p>
<p>a. Recursive <code>count-leaves</code>:</p>
<pre><code class="language-scheme editable">(define (count-leaves tree)
  (cond ((null? tree) 0)
        ((not (pair? tree)) 1)
        (else (+ (count-leaves (car tree))
                 (count-leaves (cdr tree))))))
</code></pre>
<p>b. Recursive <code>count-leaves</code> with explicit counter:</p>
<pre><code class="language-scheme editable">(define (count-leaves tree)
  (define (count-iter tree n)
    (cond ((null? tree) n)
          ((not (pair? tree)) (+ n 1))
          (else (count-iter (cdr tree)
                            (count-iter (car tree) n)))))
  (count-iter tree 0))
</code></pre>
<p><strong>Exercise
5.22.</strong>  Exercise <a href="book-Z-H-22.html#%_thm_3.12">3.12</a>
of section <a href="book-Z-H-22.html#%_sec_3.3.1">3.3.1</a> presented an <code>append</code>
procedure that appends two lists to form a new list and an <code>append!</code>
procedure that splices two lists together. Design a register machine to
implement each of these procedures. Assume that the list-structure
memory operations are available as primitive operations.</p>
<h3 id="532--maintaining-the-illusion-of-infinite-memory"><a class="header" href="#532--maintaining-the-illusion-of-infinite-memory"><a href="book-Z-H-4.html#%_toc_%_sec_5.3.2">5.3.2  Maintaining the Illusion of Infinite Memory</a></a></h3>
<p>The representation method outlined in
section <a href="book-Z-H-33.html#%_sec_5.3.1">5.3.1</a> solves the problem of
implementing list structure, provided that we have an infinite amount of
memory. With a real computer we will eventually run out of free space in
which to construct new
pairs.<a href="book-Z-H-33.html#footnote_Temp_758">^[13]{.small}^</a>
However, most of the pairs generated in a typical computation are used
only to hold intermediate results. After these results are accessed, the
pairs are no longer needed -- they are <em>garbage</em>. For instance, the
computation</p>
<pre><code class="language-scheme editable">(accumulate + 0 (filter odd? (enumerate-interval 0 n)))
</code></pre>
<p>constructs two lists: the enumeration and the result of filtering the
enumeration. When the accumulation is complete, these lists are no
longer needed, and the allocated memory can be reclaimed. If we can
arrange to collect all the garbage periodically, and if this turns out
to recycle memory at about the same rate at which we construct new
pairs, we will have preserved the illusion that there is an infinite
amount of memory.</p>
<p>In order to recycle pairs, we must have a way to determine which
allocated pairs are not needed (in the sense that their contents can no
longer influence the future of the computation). The method we shall
examine for accomplishing this is known as <em>garbage collection</em>. Garbage
collection is based on the observation that, at any moment in a Lisp
interpretation, the only objects that can affect the future of the
computation are those that can be reached by some succession of <code>car</code>
and <code>cdr</code> operations starting from the pointers that are currently in
the machine
registers.<a href="book-Z-H-33.html#footnote_Temp_759">^[14]{.small}^</a>
Any memory cell that is not so accessible may be recycled.</p>
<p>There are many ways to perform garbage collection. The method we shall
examine here is called <em>stop-and-copy</em>.
The basic idea is to divide memory into two halves: 'working
memory' and 'free memory.' When <code>cons</code> constructs pairs, it
allocates these in working memory. When working memory is full, we
perform garbage collection by locating all the useful pairs in working
memory and copying these into consecutive locations in free memory. (The
useful pairs are located by tracing all the <code>car</code> and <code>cdr</code> pointers,
starting with the machine registers.) Since we do not copy the garbage,
there will presumably be additional free memory that we can use to
allocate new pairs. In addition, nothing in the working memory is
needed, since all the useful pairs in it have been copied. Thus, if we
interchange the roles of working memory and free memory, we can continue
processing; new pairs will be allocated in the new working memory (which
was the old free memory). When this is full, we can copy the useful
pairs into the new free memory (which was the old working
memory).^[15]{.small}^](book-Z-H-33.html#footnote_Temp_760)</p>
<h4 id="implementation-of-a-stop-and-copy-garbage-collector"><a class="header" href="#implementation-of-a-stop-and-copy-garbage-collector"><a href="book-Z-H-4.html#%_toc_%_sec_Temp_761">Implementation of a stop-and-copy garbage collector</a></a></h4>
<p>We now use our register-machine language to describe the stop-and-copy
algorithm in more detail. We will assume that there is a register called
<code>root</code> that contains a pointer to a structure that
eventually points at all accessible data. This can be arranged by
storing the contents of all the machine registers in a pre-allocated
list pointed at by <code>root</code> just before starting garbage
collection.<a href="book-Z-H-33.html#footnote_Temp_762">^[16]{.small}^</a>
We also assume that, in addition to the current working memory, there is
free memory available into which we can copy the useful data. The
current working memory consists of vectors whose base addresses are in
registers called <code>the-cars</code> and
<code>the-cdrs</code>, and the free memory is in registers called
<code>new-cars</code> and <code>new-cdrs</code>.</p>
<p>Garbage collection is triggered when we exhaust the free cells in the
current working memory, that is, when a <code>cons</code> operation attempts to
increment the <code>free</code> pointer beyond the end of the memory vector. When
the garbage-collection process is complete, the <code>root</code> pointer will
point into the new memory, all objects accessible from the <code>root</code> will
have been moved to the new memory, and the <code>free</code> pointer will indicate
the next place in the new memory where a new pair can be allocated. In
addition, the roles of working memory and new memory will have been
interchanged -- new pairs will be constructed in the new memory,
beginning at the place indicated by <code>free</code>, and the (previous) working
memory will be available as the new memory for the next garbage
collection. Figure <a href="book-Z-H-33.html#%_fig_5.15">5.15</a> shows the
arrangement of memory just before and just after garbage collection.</p>
<p><img src="ch5-Z-G-8.gif" alt="" /></p>
<p><strong>Figure 5.15:</strong>  Reconfiguration of memory by the garbage-collection
process.</p>
<p>The state of the garbage-collection
process is controlled by maintaining two pointers: <code>free</code> and <code>scan</code>.
These are initialized to point to the beginning of the new memory. The
algorithm begins by relocating the pair pointed at by <code>root</code> to the
beginning of the new memory. The pair is copied, the <code>root</code> pointer is
adjusted to point to the new location, and the <code>free</code> pointer is
incremented. In addition, the old location of the pair is marked to show
that its contents have been moved. This marking is done as follows: In
the <code>car</code> position, we place a special tag that signals that this is an
already-moved object. (Such an object is traditionally called a
<em>broken
heart</em>.)^[17]{.small}^](book-Z-H-33.html#footnote_Temp_763)
In the <code>cdr</code> position we place a <em>forwarding address</em>
that points at the location to which the object has been moved.</p>
<p>After relocating the root, the garbage collector enters its basic cycle.
At each step in the algorithm, the <code>scan</code> pointer (initially pointing at
the relocated root) points at a pair that has been moved to the new
memory but whose <code>car</code> and <code>cdr</code> pointers still refer to objects in the
old memory. These objects are each relocated, and the <code>scan</code> pointer is
incremented. To relocate an object (for example, the object indicated by
the <code>car</code> pointer of the pair we are scanning) we check to see if the
object has already been moved (as indicated by the presence of a
broken-heart tag in the <code>car</code> position of the object). If the object
has not already been moved, we copy it to the place indicated by <code>free</code>,
update <code>free</code>, set up a broken heart at the object's old location, and
update the pointer to the object (in this example, the <code>car</code> pointer of
the pair we are scanning) to point to the new location. If the object
has already been moved, its forwarding address (found in the <code>cdr</code>
position of the broken heart) is substituted for the pointer in the pair
being scanned. Eventually, all accessible objects will have been moved
and scanned, at which point the <code>scan</code> pointer will overtake the <code>free</code>
pointer and the process will terminate.</p>
<p>We can specify the stop-and-copy algorithm as a sequence of instructions
for a register machine. The basic step of relocating an object is
accomplished by a subroutine called <code>relocate-old-result-in-new</code>. This
subroutine gets its argument, a pointer to the object to be relocated,
from a register named <code>old</code>. It relocates the designated
object (incrementing <code>free</code> in the process), puts a pointer to the
relocated object into a register called <code>new</code>, and
returns by branching to the entry point stored in the register
<code>relocate-continue</code>. To begin garbage collection, we invoke this
subroutine to relocate the <code>root</code> pointer, after initializing <code>free</code> and
<code>scan</code>. When the relocation of <code>root</code> has been accomplished, we install
the new pointer as the new <code>root</code> and enter the main loop of the garbage
collector.</p>
<pre><code class="language-scheme editable">begin-garbage-collection
  (assign free (const 0))
  (assign scan (const 0))
  (assign old (reg root))
  (assign relocate-continue (label reassign-root))
  (goto (label relocate-old-result-in-new))
reassign-root
  (assign root (reg new))
  (goto (label gc-loop))
</code></pre>
<p>In the main loop of the garbage collector we must determine whether
there are any more objects to be scanned. We do this by testing whether
the <code>scan</code> pointer is coincident with the <code>free</code> pointer. If the
pointers are equal, then all accessible objects have been relocated, and
we branch to <code>gc-flip</code>, which cleans things up so that we can continue
the interrupted computation. If there are still pairs to be scanned, we
call the relocate subroutine to relocate the <code>car</code> of the next pair (by
placing the <code>car</code> pointer in <code>old</code>). The <code>relocate-continue</code> register is
set up so that the subroutine will return to update the <code>car</code> pointer.</p>
<pre><code class="language-scheme editable">gc-loop
  (test (op =) (reg scan) (reg free))
  (branch (label gc-flip))
  (assign old (op vector-ref) (reg new-cars) (reg scan))
  (assign relocate-continue (label update-car))
  (goto (label relocate-old-result-in-new))
</code></pre>
<p>At <code>update-car</code>, we modify the <code>car</code> pointer of the pair being scanned,
then proceed to relocate the <code>cdr</code> of the pair. We return to
<code>update-cdr</code> when that relocation has been accomplished. After
relocating and updating the <code>cdr</code>, we are finished scanning that pair,
so we continue with the main loop.</p>
<pre><code class="language-scheme editable">update-car
  (perform
   (op vector-set!) (reg new-cars) (reg scan) (reg new))
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))
  (assign relocate-continue (label update-cdr))
  (goto (label relocate-old-result-in-new))

update-cdr
  (perform
   (op vector-set!) (reg new-cdrs) (reg scan) (reg new))
  (assign scan (op +) (reg scan) (const 1))
  (goto (label gc-loop))
</code></pre>
<p>The subroutine <code>relocate-old-result-in-new</code> relocates objects as
follows: If the object to be relocated (pointed at by <code>old</code>) is not a
pair, then we return the same pointer to the object unchanged (in
<code>new</code>). (For example, we may be scanning a pair whose <code>car</code> is the
number 4. If we represent the <code>car</code> by <code>n4</code>, as described in
section <a href="book-Z-H-33.html#%_sec_5.3.1">5.3.1</a>, then we want the
'relocated' <code>car</code> pointer to still be <code>n4</code>.) Otherwise, we must
perform the relocation. If the <code>car</code> position of the pair to be
relocated contains a broken-heart tag, then the pair has in fact already
been moved, so we retrieve the forwarding address (from the <code>cdr</code>
position of the broken heart) and return this in <code>new</code>. If the pointer
in <code>old</code> points at a yet-unmoved pair, then we move the pair to the
first free cell in new memory (pointed at by <code>free</code>) and set up the
broken heart by storing a broken-heart tag and forwarding address at the
old location. <code>Relocate-old-result-in-new</code> uses a register
<code>oldcr</code> to hold the <code>car</code> or the <code>cdr</code> of the object
pointed at by
<code>old</code>.<a href="book-Z-H-33.html#footnote_Temp_764">^[18]{.small}^</a></p>
<pre><code class="language-scheme editable">relocate-old-result-in-new
  (test (op pointer-to-pair?) (reg old))
  (branch (label pair))
  (assign new (reg old))
  (goto (reg relocate-continue))
pair
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))
  (test (op broken-heart?) (reg oldcr))
  (branch (label already-moved))
  (assign new (reg free)) ; new location for pair
  ;; Update "free" pointer.
  (assign free (op +) (reg free) (const 1))
  ;; Copy the "car" and "cdr" to new memory.
  (perform (op vector-set!)
           (reg new-cars) (reg new) (reg oldcr))
  (assign oldcr (op vector-ref) (reg the-cdrs) (reg old))
  (perform (op vector-set!)
           (reg new-cdrs) (reg new) (reg oldcr))
  ;; Construct the broken heart.
  (perform (op vector-set!)
           (reg the-cars) (reg old) (const broken-heart))
  (perform
   (op vector-set!) (reg the-cdrs) (reg old) (reg new))
  (goto (reg relocate-continue))
already-moved
  (assign new (op vector-ref) (reg the-cdrs) (reg old))
  (goto (reg relocate-continue))
</code></pre>
<p>At the very end of the garbage-collection process, we interchange the
role of old and new memories by interchanging pointers: interchanging
<code>the-cars</code> with <code>new-cars</code>, and <code>the-cdrs</code> with <code>new-cdrs</code>. We will then
be ready to perform another garbage collection the next time memory runs
out.</p>
<pre><code class="language-scheme editable">gc-flip
  (assign temp (reg the-cdrs))
  (assign the-cdrs (reg new-cdrs))
  (assign new-cdrs (reg temp))
  (assign temp (reg the-cars))
  (assign the-cars (reg new-cars))
  (assign new-cars (reg temp))
</code></pre>
<hr />
<p>^[5]{.small}^](book-Z-H-33.html#call_footnote_Temp_744)
We could represent memory as lists of items. However, the access time
would then not be independent of the index, since accessing the <em>n</em>th
element of a list requires <em>n</em> - 1 <code>cdr</code> operations.</p>
<p>^[6]{.small}^](book-Z-H-33.html#call_footnote_Temp_745)
For completeness, we should specify a <code>make-vector</code> operation that
constructs vectors. However, in the present application we will use
vectors only to model fixed divisions of the computer memory.</p>
<p>^[7]{.small}^](book-Z-H-33.html#call_footnote_Temp_747)
This is precisely the same 'tagged
data' idea we introduced in chapter 2 for dealing with generic
operations. Here, however, the data types are included at the primitive
machine level rather than constructed through the use of lists.</p>
<p>^[8]{.small}^](book-Z-H-33.html#footnote_Temp_748)
Type information may be encoded in a variety of ways, depending on the
details of the machine on which the Lisp system is to be implemented.
The execution efficiency of Lisp programs will be strongly dependent on
how cleverly this choice is made, but it is difficult to formulate
general design rules for good choices. The most straightforward way to
implement typed pointers is to allocate a fixed set of bits in each
pointer to be a <em>type field</em> that encodes the data type.
Important questions to be addressed in designing such a representation
include the following: How many type bits are required? How large must
the vector indices be? How efficiently can the primitive machine
instructions be used to manipulate the type fields of pointers? Machines
that include special hardware for the efficient handling of type fields
are said to have <em>tagged architectures</em>.</p>
<p>^[9]{.small}^](book-Z-H-33.html#footnote_Temp_749)
This decision on the
representation of numbers
determines whether <code>eq?</code>, which tests equality of pointers, can be used
to test for equality of numbers. If the pointer contains the number
itself, then equal numbers will have the same pointer. But if the
pointer contains the index of a location where the number is stored,
equal numbers will be guaranteed to have equal pointers only if we are
careful never to store the same number in more than one location.</p>
<p>^[10]{.small}^](book-Z-H-33.html#footnote_Temp_750)
This is just like writing a number as a sequence of digits, except that
each 'digit' is a number between 0 and the largest number that can
be stored in a single pointer.</p>
<p>^[11]{.small}^](book-Z-H-33.html#call_footnote_Temp_752)
There are other ways of finding free storage. For example, we could link
together all the unused pairs into a <em>free list</em>. Our
free locations are consecutive (and hence can be accessed by
incrementing a pointer) because we are using a compacting garbage
collector, as we will see in
section <a href="book-Z-H-33.html#%_sec_5.3.2">5.3.2</a>.</p>
<p>^[12]{.small}^](book-Z-H-33.html#call_footnote_Temp_753)
This is essentially the implementation of <code>cons</code> in terms of <code>set-car!</code>
and <code>set-cdr!</code>, as described in
section <a href="book-Z-H-22.html#%_sec_3.3.1">3.3.1</a>. The operation
<code>get-new-pair</code> used in that implementation is realized here by the
<code>free</code> pointer.</p>
<p>^[13]{.small}^](book-Z-H-33.html#footnote_Temp_758)
This may not be true eventually, because memories may get large enough
so that it would be impossible to run out of free memory in the lifetime
of the computer. For example, there are about 3× 10^13^, microseconds in
a year, so if we were to <code>cons</code> once per microsecond we would need about
10^15^ cells of memory to build a machine that could operate for 30
years without running out of memory. That much memory seems absurdly
large by today's standards, but it is not physically impossible. On the
other hand, processors are getting faster and a future computer may have
large numbers of processors operating in parallel on a single memory, so
it may be possible to use up memory much faster than we have postulated.</p>
<p>^[14]{.small}^](book-Z-H-33.html#footnote_Temp_759)
We assume here that the stack is represented as a list as described in
section <a href="book-Z-H-33.html#%_sec_5.3.1">5.3.1</a>, so that items on the
stack are accessible via the pointer in the stack register.</p>
<p>^[15]{.small}^](book-Z-H-33.html#footnote_Temp_760)
This idea was invented and first implemented by Minsky,
as part of the implementation of Lisp for the PDP-1 at
the MIT Research Laboratory of Electronics. It was
further developed by Fenichel and
Yochelson (1969) for use in the Lisp implementation for
the Multics time-sharing system. Later,
Baker (1978) developed a 'real-time' version of the
method, which does not require the computation to stop during garbage
collection. Baker's idea was extended by
Hewitt, Lieberman, and Moon
(see Lieberman and Hewitt 1983) to take advantage of the fact that some
structure is more volatile and other structure is more permanent.</p>
<p>An alternative commonly used garbage-collection technique is the
<em>mark-sweep</em> method. This consists of
tracing all the structure accessible from the machine registers and
marking each pair we reach. We then scan all of memory, and any location
that is unmarked is 'swept up' as garbage and made available for
reuse. A full discussion of the mark-sweep method can be
found in Allen 1978.</p>
<p>The Minsky-Fenichel-Yochelson algorithm is the dominant algorithm in use
for large-memory systems because it examines only the useful part of
memory. This is in contrast to mark-sweep, in which the sweep phase must
check all of memory. A second advantage of stop-and-copy is that it is a
<em>compacting</em> garbage collector. That is,
at the end of the garbage-collection phase the useful data will have
been moved to consecutive memory locations, with all garbage pairs
compressed out. This can be an extremely important performance
consideration in machines with virtual memory, in which accesses to
widely separated memory addresses may require extra paging operations.</p>
<p>^[16]{.small}^](book-Z-H-33.html#footnote_Temp_762)
This list of registers does not include the registers used by the
storage-allocation system -- <code>root</code>, <code>the-cars</code>, <code>the-cdrs</code>, and the
other registers that will be introduced in this section.</p>
<p>^[17]{.small}^](book-Z-H-33.html#footnote_Temp_763)
The term <em>broken heart</em> was coined by David Cressey, who
wrote a garbage collector for MDL, a
dialect of Lisp developed at MIT during the early 1970s.</p>
<p>^[18]{.small}^](book-Z-H-33.html#footnote_Temp_764)
The garbage collector uses the low-level predicate <code>pointer-to-pair?</code>
instead of the list-structure <code>pair?</code> operation because in a real system
there might be various things that are treated as pairs for
garbage-collection purposes. For example, in a Scheme system that
conforms to the IEEE standard a procedure object may be implemented as a
special kind of 'pair' that doesn't satisfy the <code>pair?</code>
predicate. For simulation purposes, <code>pointer-to-pair?</code> can be
implemented as <code>pair?</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="5.2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="5.4.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="5.2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="5.4.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="./highlight.js"></script>
        <script src="./src/languages/scheme.min.js"></script>
        <script src="./biwascheme.min.js"></script>
        <script src="./biwascheme_run_logic.js"></script>


    </div>
    </body>
</html>
