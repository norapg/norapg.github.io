<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Environment Model of Evaluation - SICP</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./src/styles/docco.min.css">
        <link rel="stylesheet" href="./run_button_style.css">
        <link rel="stylesheet" href="./custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SICP</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="32--the-environment-model-of-evaluation"><a class="header" href="#32--the-environment-model-of-evaluation"><a href="book-Z-H-4.html#%_toc_%_sec_3.2">3.2  The Environment Model of Evaluation</a></a></h2>
<p>When we introduced compound procedures in chapter 1, we
used the substitution model of evaluation
(section <a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a>) to define what is meant
by applying a procedure to arguments:</p>
<ul>
<li>To apply a compound procedure to arguments, evaluate the body of the
procedure with each formal parameter replaced by the corresponding
argument.</li>
</ul>
<p>Once we admit assignment into our programming language, such a
definition is no longer adequate. In particular,
section <a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a> argued that, in the
presence of assignment, a variable can no longer be considered to be
merely a name for a value. Rather, a variable must somehow designate a
``place'' in which values can be stored. In our new model of
evaluation, these places will be maintained in structures called
<em>environments</em>.</p>
<p>An environment is a sequence of <em>frames</em>. Each frame is a
table (possibly empty) of <em>bindings</em>, which associate
variable names with their corresponding values. (A single frame may
contain at most one binding for any variable.) Each frame also has a
pointer to its <em>enclosing environment</em>,
unless, for the purposes of discussion, the frame is considered to be
<em>global</em>. The <em>value of a
variable</em> with respect to an environment is the value given by the
binding of the variable in the first frame in the environment that
contains a binding for that variable. If no frame in the sequence
specifies a binding for the variable, then the variable is said to be
<em>unbound</em> in the environment.</p>
<p><img src="ch3-Z-G-2.gif" alt="" />{border="0"}</p>
<p><strong>Figure 3.1:</strong>  A simple environment structure.</p>
<p>Figure <a href="book-Z-H-21.html#%_fig_3.1">3.1</a> shows a simple environment
structure consisting of three frames, labeled I, II, and III. In the
diagram, A, B, C, and D are pointers to environments. C and D point to
the same environment. The variables <code>z</code> and <code>x</code> are bound in frame II,
while <code>y</code> and <code>x</code> are bound in frame I. The value of <code>x</code> in environment
D is 3. The value of <code>x</code> with respect to environment B is also 3. This
is determined as follows: We examine the first frame in the sequence
(frame III) and do not find a binding for <code>x</code>, so we proceed to the
enclosing environment D and find the binding in frame I. On the other
hand, the value of <code>x</code> in environment A is 7, because the first frame in
the sequence (frame II) contains a binding of <code>x</code> to 7. With respect to
environment A, the binding of <code>x</code> to 7 in frame II is said to
<em>shadow</em> the binding of <code>x</code> to 3 in frame I.</p>
<p>The environment is crucial to the evaluation process, because it
determines the context in which an expression should be evaluated.
Indeed, one could say that expressions in a programming language do not,
in themselves, have any meaning. Rather, an expression acquires a
meaning only with respect to some environment in which it is evaluated.
Even the interpretation of an expression as straightforward as <code>(+ 1 1)</code>
depends on an understanding that one is operating in a context in which
<code>+</code> is the symbol for addition. Thus, in our model of evaluation we will
always speak of evaluating an expression with respect to some
environment. To describe interactions with the interpreter, we will
suppose that there is a global environment, consisting of
a single frame (with no enclosing environment) that includes values for
the symbols associated with the primitive procedures. For example, the
idea that <code>+</code> is the symbol for addition is captured by saying that the
symbol <code>+</code> is bound in the global environment to the primitive addition
procedure.</p>
<h3 id="321--the-rules-for-evaluation"><a class="header" href="#321--the-rules-for-evaluation"><a href="book-Z-H-4.html#%_toc_%_sec_3.2.1">3.2.1  The Rules for Evaluation</a></a></h3>
<p>The overall specification of how the interpreter
evaluates a combination remains the same as when we first introduced it
in section <a href="book-Z-H-10.html#%_sec_1.1.3">1.1.3</a>:</p>
<ul>
<li>To evaluate a combination:</li>
</ul>
<blockquote>
<ol>
<li>
<p>Evaluate the subexpressions of the
combination.<a href="book-Z-H-21.html#footnote_Temp_342">^[12]{.small}^</a>{#call_footnote_Temp_342}</p>
</li>
<li>
<p>Apply the value of the operator subexpression to the values of the
operand subexpressions.</p>
</li>
</ol>
</blockquote>
<p>The environment model of evaluation replaces the substitution model in
specifying what it means to apply a compound procedure to arguments.</p>
<p>In the environment model of evaluation, a procedure is always a pair
consisting of some code and a pointer to an environment. Procedures are
created in one way only: by evaluating a <code>lambda</code> expression.
This produces a procedure whose code is obtained from the
text of the <code>lambda</code> expression and whose environment is the environment
in which the <code>lambda</code> expression was evaluated to produce the procedure.
For example, consider the procedure definition</p>
<pre><code class="language-scheme editable">(define (square x)
  (* x x))
</code></pre>
<p>evaluated in the global environment. The procedure definition syntax is
just syntactic sugar for an underlying implicit <code>lambda</code> expression. It
would have been equivalent to have used</p>
<pre><code class="language-scheme editable">(define square
  (lambda (x) (* x x)))
</code></pre>
<p>which evaluates <code>(lambda (x) (* x x))</code> and binds <code>square</code> to the
resulting value, all in the global environment.</p>
<p>Figure <a href="book-Z-H-21.html#%_fig_3.2">3.2</a> shows the result of evaluating
this <code>define</code> expression. The procedure object is a pair whose code
specifies that the procedure has one formal parameter, namely <code>x</code>, and a
procedure body <code>(* x x)</code>. The environment part of the procedure is a
pointer to the global environment, since that is the environment in
which the <code>lambda</code> expression was evaluated to produce the procedure. A
new binding, which associates the procedure object with the symbol
<code>square</code>, has been added to the global frame. In general, <code>define</code>
creates definitions by adding bindings to frames.</p>
<p><img src="ch3-Z-G-3.gif" alt="" />{border="0"}</p>
<p><strong>Figure 3.2:</strong>  Environment structure produced by evaluating
<code>(define (square x) (* x x))</code> in the global environment.</p>
<p>Now that we have seen how procedures are created, we can describe how
procedures are applied. The environment model specifies: To apply a
procedure to arguments, create a new environment containing a frame that
binds the parameters to the values of the arguments. The enclosing
environment of this frame is the environment specified by the procedure.
Now, within this new environment, evaluate the procedure body.</p>
<p>To show how this rule is followed,
figure <a href="book-Z-H-21.html#%_fig_3.3">3.3</a> illustrates the environment
structure created by evaluating the expression <code>(square 5)</code> in the
global environment, where <code>square</code> is the procedure generated in
figure <a href="book-Z-H-21.html#%_fig_3.2">3.2</a>. Applying the procedure results
in the creation of a new environment, labeled E1 in the figure, that
begins with a frame in which <code>x</code>, the formal parameter for the
procedure, is bound to the argument 5. The pointer leading upward from
this frame shows that the frame's enclosing environment is the global
environment. The global environment is chosen here, because this is the
environment that is indicated as part of the <code>square</code> procedure object.
Within E1, we evaluate the body of the procedure, <code>(* x x)</code>. Since the
value of <code>x</code> in E1 is 5, the result is <code>(* 5 5)</code>, or 25.</p>
<p><img src="ch3-Z-G-4.gif" alt="" />{border="0"}</p>
<p><strong>Figure 3.3:</strong>  Environment created by evaluating <code>(square 5)</code> in the
global environment.</p>
<p>The environment model of procedure application can be summarized by two
rules:</p>
<ul>
<li>
<p>A procedure object is applied to a set of arguments by constructing a
frame, binding the formal parameters of the procedure to the arguments
of the call, and then evaluating the body of the procedure in the
context of the new environment constructed. The new frame has as its
enclosing environment the environment part of the procedure object
being applied.</p>
</li>
<li>
<p>A procedure is created by evaluating a <code>lambda</code> expression relative to
a given environment. The resulting procedure object is a pair
consisting of the text of the <code>lambda</code> expression and a pointer to the
environment in which the procedure was created.</p>
</li>
</ul>
<p>We also specify that defining a symbol using <code>define</code>
creates a binding in the current environment frame and assigns to the
symbol the indicated
value.<a href="book-Z-H-21.html#footnote_Temp_343">^[13]{.small}^</a>{#call_footnote_Temp_343}
Finally, we specify the behavior of <code>set!</code>, the operation that forced us
to introduce the environment model in the first place. Evaluating the
expression <code>(set! &lt;</code><em><code>variable</code></em><code>&gt; &lt;</code><em><code>value</code></em><code>&gt;)</code> in some environment
locates the binding of the variable in the environment and changes that
binding to indicate the new value. That is, one finds the first frame in
the environment that contains a binding for the variable and modifies
that frame. If the variable is unbound in the environment, then <code>set!</code>
signals an error.</p>
<p>These evaluation rules, though considerably more complex than the
substitution model, are still reasonably straightforward. Moreover, the
evaluation model, though abstract, provides a correct description of how
the interpreter evaluates expressions. In chapter 4 we shall see how
this model can serve as a blueprint for implementing a working
interpreter. The following sections elaborate the details of the model
by analyzing some illustrative programs.</p>
<h3 id="322--applying-simple-procedures"><a class="header" href="#322--applying-simple-procedures"><a href="book-Z-H-4.html#%_toc_%_sec_3.2.2">3.2.2  Applying Simple Procedures</a></a></h3>
<p>When we introduced the
substitution model in section <a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a> we
showed how the combination <code>(f 5)</code> evaluates to 136, given the following
procedure definitions:</p>
<pre><code class="language-scheme editable">(define (square x)
  (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
</code></pre>
<p>We can analyze the same example using the environment model.
Figure <a href="book-Z-H-21.html#%_fig_3.4">3.4</a> shows the three procedure
objects created by evaluating the definitions of <code>f</code>, <code>square</code>, and
<code>sum-of-squares</code> in the global environment. Each procedure object
consists of some code, together with a pointer to the global
environment.</p>
<p><img src="ch3-Z-G-5.gif" alt="" />{border="0"}</p>
<p><strong>Figure 3.4:</strong>  Procedure objects in the global frame.</p>
<p>In figure <a href="book-Z-H-21.html#%_fig_3.5">3.5</a> we see the environment
structure created by evaluating the expression <code>(f 5)</code>. The call to <code>f</code>
creates a new environment E1 beginning with a frame in which <code>a</code>, the
formal parameter of <code>f</code>, is bound to the argument 5. In E1, we evaluate
the body of <code>f</code>:</p>
<pre><code class="language-scheme editable">(sum-of-squares (+ a 1) (* a 2))
</code></pre>
<p><img src="ch3-Z-G-6.gif" alt="" />{border="0"}</p>
<p><strong>Figure 3.5:</strong>  Environments created by evaluating <code>(f 5)</code> using the
procedures in figure <a href="book-Z-H-21.html#%_fig_3.4">3.4</a>.</p>
<p>To evaluate this combination, we first evaluate the subexpressions. The
first subexpression, <code>sum-of-squares</code>, has a value that is a procedure
object. (Notice how this value is found: We first look in the first
frame of E1, which contains no binding for <code>sum-of-squares</code>. Then we
proceed to the enclosing environment, i.e. the global environment, and
find the binding shown in figure <a href="book-Z-H-21.html#%_fig_3.4">3.4</a>.) The
other two subexpressions are evaluated by applying the primitive
operations <code>+</code> and <code>*</code> to evaluate the two combinations <code>(+ a 1)</code> and
<code>(* a 2)</code> to obtain 6 and 10, respectively.</p>
<p>Now we apply the procedure object <code>sum-of-squares</code> to the arguments 6
and 10. This results in a new environment E2 in which the formal
parameters <code>x</code> and <code>y</code> are bound to the arguments. Within E2 we evaluate
the combination <code>(+ (square x) (square y))</code>. This leads us to evaluate
<code>(square x)</code>, where <code>square</code> is found in the global frame and <code>x</code> is 6.
Once again, we set up a new environment, E3, in which <code>x</code> is bound to 6,
and within this we evaluate the body of <code>square</code>, which is <code>(* x x)</code>.
Also as part of applying <code>sum-of-squares</code>, we must evaluate the
subexpression <code>(square y)</code>, where <code>y</code> is 10. This second call to
<code>square</code> creates another environment, E4, in which <code>x</code>, the formal
parameter of <code>square</code>, is bound to 10. And within E4 we must evaluate
<code>(* x x)</code>.</p>
<p>The important point to observe is that each call to <code>square</code> creates a
new environment containing a binding for <code>x</code>. We can see here how the
different frames serve to keep separate the different local variables
all named <code>x</code>. Notice that each frame created by <code>square</code> points to the
global environment, since this is the environment indicated by the
<code>square</code> procedure object.</p>
<p>After the subexpressions are evaluated, the results are returned. The
values generated by the two calls to <code>square</code> are added by
<code>sum-of-squares</code>, and this result is returned by <code>f</code>. Since our focus
here is on the environment structures, we will not dwell on how these
returned values are passed from call to call; however, this is also an
important aspect of the evaluation process, and we will return to it in
detail in chapter 5.</p>
<p><strong>Exercise
3.9.</strong>  In
section <a href="book-Z-H-11.html#%_sec_1.2.1">1.2.1</a> we used the substitution
model to analyze two procedures for computing factorials, a recursive
version</p>
<pre><code class="language-scheme editable">(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
</code></pre>
<p>and an iterative version</p>
<pre><code class="language-scheme editable">(define (factorial n)
  (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (&gt; counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
</code></pre>
<p>Show the environment structures created by evaluating <code>(factorial 6)</code>
using each version of the <code>factorial</code>
procedure.<a href="book-Z-H-21.html#footnote_Temp_345">^[14]{.small}^</a>{#call_footnote_Temp_345}</p>
<h3 id="323--frames-as-the-repository-of-local-state"><a class="header" href="#323--frames-as-the-repository-of-local-state"><a href="book-Z-H-4.html#%_toc_%_sec_3.2.3">3.2.3  Frames as the Repository of Local State</a></a></h3>
<p>We can turn
to the environment model to see how procedures and assignment can be
used to represent objects with local state. As an example, consider the
``withdrawal processor'' from
section <a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a> created by calling the
procedure</p>
<pre><code class="language-scheme editable">(define (make-withdraw balance)
  (lambda (amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")))
</code></pre>
<p>Let us describe the evaluation of</p>
<pre><code class="language-scheme editable">(define W1 (make-withdraw 100))
</code></pre>
<p>followed by</p>
<pre><code class="language-scheme editable">(W1 50)
</code></pre>
<p><em><code>50</code></em></p>
<p>Figure <a href="book-Z-H-21.html#%_fig_3.6">3.6</a> shows the result of defining
the <code>make-withdraw</code> procedure in the global environment. This produces a
procedure object that contains a pointer to the global environment. So
far, this is no different from the examples we have already seen, except
that the body of the procedure is itself a <code>lambda</code> expression.</p>
<p><img src="ch3-Z-G-7.gif" alt="" />{border="0"}</p>
<p><strong>Figure 3.6:</strong>  Result of defining <code>make-withdraw</code> in the global
environment.</p>
<p>The interesting part of the computation happens when we apply the
procedure <code>make-withdraw</code> to an argument:</p>
<pre><code class="language-scheme editable">(define W1 (make-withdraw 100))
</code></pre>
<p>We begin, as usual, by setting up an environment E1 in which the formal
parameter <code>balance</code> is bound to the argument 100. Within this
environment, we evaluate the body of <code>make-withdraw</code>, namely the
<code>lambda</code> expression. This constructs a new procedure object, whose code
is as specified by the <code>lambda</code> and whose environment is E1, the
environment in which the <code>lambda</code> was evaluated to produce the
procedure. The resulting procedure object is the value returned by the
call to <code>make-withdraw</code>. This is bound to <code>W1</code> in the global
environment, since the <code>define</code> itself is being evaluated in the global
environment. Figure <a href="book-Z-H-21.html#%_fig_3.7">3.7</a> shows the
resulting environment structure.</p>
<p><img src="ch3-Z-G-8.gif" alt="" />{border="0"}</p>
<p><strong>Figure 3.7:</strong>  Result of evaluating <code>(define W1 (make-withdraw 100))</code>.</p>
<p>Now we can analyze what happens when <code>W1</code> is applied to an argument:</p>
<pre><code class="language-scheme editable">(W1 50)
</code></pre>
<p><em><code>50</code></em></p>
<p>We begin by constructing a frame in which <code>amount</code>, the formal parameter
of <code>W1</code>, is bound to the argument 50. The crucial point to observe is
that this frame has as its enclosing environment not the global
environment, but rather the environment E1, because this is the
environment that is specified by the <code>W1</code> procedure object. Within this
new environment, we evaluate the body of the procedure:</p>
<pre><code class="language-scheme editable">(if (&gt;= balance amount)
    (begin (set! balance (- balance amount))
           balance)
    "Insufficient funds")
</code></pre>
<p>The resulting environment structure is shown in
figure <a href="book-Z-H-21.html#%_fig_3.8">3.8</a>. The expression being evaluated
references both <code>amount</code> and <code>balance</code>. <code>Amount</code> will be found in the
first frame in the environment, while <code>balance</code> will be found by
following the enclosing-environment pointer to E1.</p>
<p><img src="ch3-Z-G-9.gif" alt="" />{border="0"}</p>
<p><strong>Figure 3.8:</strong>  Environments created by applying the procedure object
<code>W1</code>.</p>
<p>When the <code>set!</code> is executed, the binding of <code>balance</code> in E1 is changed.
At the completion of the call to <code>W1</code>, <code>balance</code> is 50, and the frame
that contains <code>balance</code> is still pointed to by the procedure object
<code>W1</code>. The frame that binds <code>amount</code> (in which we executed the code that
changed <code>balance</code>) is no longer relevant, since the procedure call that
constructed it has terminated, and there are no pointers to that frame
from other parts of the environment. The next time <code>W1</code> is called, this
will build a new frame that binds <code>amount</code> and whose enclosing
environment is E1. We see that E1 serves as the ``place'' that holds
the local state variable for the procedure object <code>W1</code>.
Figure <a href="book-Z-H-21.html#%_fig_3.9">3.9</a> shows the situation after the
call to <code>W1</code>.</p>
<p><img src="ch3-Z-G-10.gif" alt="" />{border="0"}</p>
<p><strong>Figure 3.9:</strong>  Environments after the call to <code>W1</code>.</p>
<p>Observe what happens when we create a second ``withdraw'' object by
making another call to <code>make-withdraw</code>:</p>
<pre><code class="language-scheme editable">(define W2 (make-withdraw 100))
</code></pre>
<p>This produces the environment structure of
figure <a href="book-Z-H-21.html#%_fig_3.10">3.10</a>, which shows that <code>W2</code> is a
procedure object, that is, a pair with some code and an environment. The
environment E2 for <code>W2</code> was created by the call to <code>make-withdraw</code>. It
contains a frame with its own local binding for <code>balance</code>. On the other
hand, <code>W1</code> and <code>W2</code> have the same code: the code specified by the
<code>lambda</code> expression in the body of
<code>make-withdraw</code>.<a href="book-Z-H-21.html#footnote_Temp_346">^[15]{.small}^</a>{#call_footnote_Temp_346}
We see here why <code>W1</code> and <code>W2</code> behave as independent objects. Calls to
<code>W1</code> reference the state variable <code>balance</code> stored in E1, whereas calls
to <code>W2</code> reference the <code>balance</code> stored in E2. Thus, changes to the local
state of one object do not affect the other object.</p>
<p><img src="ch3-Z-G-11.gif" alt="" />{border="0"}</p>
<p><strong>Figure 3.10:</strong>  Using <code>(define W2 (make-withdraw 100))</code> to create a
second object.</p>
<p><strong>Exercise 3.10.</strong>  In the <code>make-withdraw</code> procedure,
the local variable <code>balance</code> is created as a parameter of
<code>make-withdraw</code>. We could also create the local state variable
explicitly, using <code>let</code>, as follows:</p>
<pre><code class="language-scheme editable">(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (&gt;= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
</code></pre>
<p>Recall from
section <a href="book-Z-H-12.html#%_sec_1.3.2">1.3.2</a> that <code>let</code> is simply
syntactic sugar for a procedure call:</p>
<pre><code class="language-scheme editable">(let ((&lt;var&gt; &lt;exp&gt;)) &lt;body&gt;)
</code></pre>
<p>is interpreted as an alternate syntax for</p>
<pre><code class="language-scheme editable">((lambda (&lt;var&gt;) &lt;body&gt;) &lt;exp&gt;)
</code></pre>
<p>Use the environment model to analyze this alternate version of
<code>make-withdraw</code>, drawing figures like the ones above to illustrate the
interactions</p>
<pre><code class="language-scheme editable">(define W1 (make-withdraw 100))

(W1 50)

(define W2 (make-withdraw 100))
</code></pre>
<p>Show that the two versions of <code>make-withdraw</code> create objects with the
same behavior. How do the environment structures differ for the two
versions?</p>
<h3 id="324--internal-definitions"><a class="header" href="#324--internal-definitions"><a href="book-Z-H-4.html#%_toc_%_sec_3.2.4">3.2.4  Internal Definitions</a></a></h3>
<p>Section <a href="book-Z-H-10.html#%_sec_1.1.8">1.1.8</a> introduced the idea that
procedures can have internal definitions, thus leading to a block
structure as in the following procedure to compute square roots:</p>
<pre><code class="language-scheme editable">(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
</code></pre>
<p>Now we can use the environment model to see why these internal
definitions behave as desired.
Figure <a href="book-Z-H-21.html#%_fig_3.11">3.11</a> shows the point in the
evaluation of the expression <code>(sqrt 2)</code> where the internal procedure
<code>good-enough?</code> has been called for the first time with <code>guess</code> equal to
1.</p>
<p><img src="ch3-Z-G-12.gif" alt="" />{border="0"}</p>
<p><strong>Figure 3.11:</strong>  <code>Sqrt</code> procedure with internal definitions.</p>
<p>Observe the structure of the environment. <code>Sqrt</code> is a symbol in the
global environment that is bound to a procedure object whose associated
environment is the global environment. When <code>sqrt</code> was called, a new
environment E1 was formed, subordinate to the global environment, in
which the parameter <code>x</code> is bound to 2. The body of <code>sqrt</code> was then
evaluated in E1. Since the first expression in the body of <code>sqrt</code> is</p>
<pre><code class="language-scheme editable">(define (good-enough? guess)
  (&lt; (abs (- (square guess) x)) 0.001))
</code></pre>
<p>evaluating this expression defined the procedure <code>good-enough?</code> in the
environment E1. To be more precise, the symbol <code>good-enough?</code> was added
to the first frame of E1, bound to a procedure object whose associated
environment is E1. Similarly, <code>improve</code> and <code>sqrt-iter</code> were defined as
procedures in E1. For conciseness,
figure <a href="book-Z-H-21.html#%_fig_3.11">3.11</a> shows only the procedure
object for <code>good-enough?</code>.</p>
<p>After the local procedures were defined, the expression
<code>(sqrt-iter 1.0)</code> was evaluated, still in environment E1. So the
procedure object bound to <code>sqrt-iter</code> in E1 was called with 1 as an
argument. This created an environment E2 in which <code>guess</code>, the parameter
of <code>sqrt-iter</code>, is bound to 1. <code>Sqrt-iter</code> in turn called <code>good-enough?</code>
with the value of <code>guess</code> (from E2) as the argument for <code>good-enough?</code>.
This set up another environment, E3, in which <code>guess</code> (the parameter of
<code>good-enough?</code>) is bound to 1. Although <code>sqrt-iter</code> and <code>good-enough?</code>
both have a parameter named <code>guess</code>, these are two distinct local
variables located in different frames. Also, E2 and E3 both have E1 as
their enclosing environment, because the <code>sqrt-iter</code> and <code>good-enough?</code>
procedures both have E1 as their environment part. One consequence of
this is that the symbol <code>x</code> that appears in the body of <code>good-enough?</code>
will reference the binding of <code>x</code> that appears in E1, namely the value
of <code>x</code> with which the original <code>sqrt</code> procedure was called. The
environment model thus explains the two key properties that make local
procedure definitions a useful technique for modularizing programs:</p>
<ul>
<li>The names of the local procedures do not interfere with names external
to the enclosing procedure, because the local procedure names will be
bound in the frame that the procedure creates when it is run, rather
than being bound in the global environment.</li>
<li>The local procedures can access the arguments of the enclosing
procedure, simply by using parameter names as free variables. This is
because the body of the local procedure is evaluated in an environment
that is subordinate to the evaluation environment for the enclosing
procedure.</li>
</ul>
<p><strong>Exercise
3.11.</strong>  In
section <a href="book-Z-H-21.html#%_sec_3.2.3">3.2.3</a> we saw how the environment
model described the behavior of procedures with local state. Now we have
seen how internal definitions work. A typical message-passing procedure
contains both of these aspects. Consider the bank account procedure of
section <a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>:</p>
<pre><code class="language-scheme editable">(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown request -- MAKE-ACCOUNT"
                       m))))
  dispatch)
</code></pre>
<p>Show the environment structure generated by the sequence of interactions</p>
<pre><code class="language-scheme editable">(define acc (make-account 50))

((acc 'deposit) 40)
</code></pre>
<p><em><code>90</code></em></p>
<pre><code class="language-scheme editable">((acc 'withdraw) 60)
</code></pre>
<p><em><code>30</code></em></p>
<p>Where is the local state for <code>acc</code> kept? Suppose we define another
account</p>
<pre><code class="language-scheme editable">(define acc2 (make-account 100))
</code></pre>
<p>How are the local states for the two accounts kept distinct? Which parts
of the environment structure are shared between <code>acc</code> and <code>acc2</code>?</p>
<hr />
<p>^[12]{.small}^](book-Z-H-21.html#call_footnote_Temp_342){#footnote_Temp_342}
Assignment introduces a subtlety into step 1 of the evaluation rule. As
shown in exercise <a href="book-Z-H-20.html#%_thm_3.8">3.8</a>, the presence of
assignment allows us to write expressions that will produce different
values depending on the order in which the subexpressions in a
combination are evaluated. Thus, to be
precise, we should specify an evaluation order in step 1 (e.g., left to
right or right to left). However, this order should always be considered
to be an implementation detail, and one should never write programs that
depend on some particular order. For instance, a sophisticated compiler
might optimize a program by varying the order in which subexpressions
are evaluated.</p>
<p>^[13]{.small}^](book-Z-H-21.html#call_footnote_Temp_343){#footnote_Temp_343}
If there is already a binding for the variable in the current frame,
then the binding is changed. This is convenient because it allows
redefinition of symbols; however, it also means that <code>define</code> can be
used to change values, and this brings up the issues of assignment
without explicitly using <code>set!</code>. Because of this, some
people prefer redefinitions of existing symbols to signal errors or
warnings.</p>
<p>^[14]{.small}^](book-Z-H-21.html#call_footnote_Temp_345){#footnote_Temp_345}
The environment model will not clarify our claim in
section <a href="book-Z-H-11.html#%_sec_1.2.1">1.2.1</a> that the interpreter can
execute a procedure such as <code>fact-iter</code> in a constant amount of space
using tail recursion. We will discuss tail recursion when we
deal with the control structure of the
interpreter in section <a href="book-Z-H-34.html#%_sec_5.4">5.4</a>.</p>
<p>^[15]{.small}^](book-Z-H-21.html#call_footnote_Temp_346){#footnote_Temp_346}
Whether <code>W1</code> and <code>W2</code> share the same physical code stored in the
computer, or whether they each keep a copy of the code, is a detail of
the implementation. For the interpreter we implement in chapter 4, the
code is in fact shared.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="3.1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="3.3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="3.1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="3.3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="./highlight.js"></script>
        <script src="./src/languages/scheme.min.js"></script>
        <script src="./biwascheme.min.js"></script>
        <script src="./biwascheme_run_logic.js"></script>


    </div>
    </body>
</html>
