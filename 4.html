<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Metalinguistic Abstraction - SICP</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./src/styles/docco.min.css">
        <link rel="stylesheet" href="./run_button_style.css">
        <link rel="stylesheet" href="./custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SICP</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="section" class="chapter"><a class="header" href="#section"></a></h1>
<p><a href="book-Z-H-4.html#%_toc_%_chap_4">Chapter 4</a></p>
<p><a href="book-Z-H-4.html#%_toc_%_chap_4">Metalinguistic Abstraction</a></p>
<div class="info">
`...` It\'s in words that the magic is \-- Abracadabra, Open Sesame,
and the rest \-- but the magic words in one story aren\'t magical in 
the next. The real magic is to understand which words work, and when,
and for what; the trick is to learn the trick.\
`...` And those words are made from the letters of our alphabet: a
couple-dozen squiggles we can draw with the pen. This is the key! And
the treasure, too, if we can only get our hands on it! It\'s as if
\-- as if the key to the treasure *is* the treasure!
<p>John Barth, <em>Chimera</em></p>
</div>
<p>In our study of program design, we have seen that expert programmers
control the complexity of their designs with the same general techniques
used by designers of all complex systems. They combine primitive
elements to form compound objects, they abstract compound objects to
form higher-level building blocks, and they preserve modularity by
adopting appropriate large-scale views of system structure. In
illustrating these techniques, we have used Lisp as a language for
describing processes and for constructing computational data objects and
processes to model complex phenomena in the real world. However, as we
confront increasingly complex problems, we will find that Lisp, or
indeed any fixed programming language, is not sufficient for our needs.
We must constantly turn to new languages in order to express our ideas
more effectively. Establishing new languages is a powerful strategy for
controlling complexity in engineering design; we can often enhance our
ability to deal with a complex problem by adopting a new language that
enables us to describe (and hence to think about) the problem in a
different way, using primitives, means of combination, and means of
abstraction that are particularly well suited to the problem at
hand.<a href="book-Z-H-25.html#footnote_Temp_508">^[1]{.small}^</a>{#call_footnote_Temp_508}</p>
<p>Programming is endowed with a multitude of
languages. There are physical languages, such as the machine languages
for particular computers. These languages are concerned with the
representation of data and control in terms of individual bits of
storage and primitive machine instructions. The machine-language
programmer is concerned with using the given hardware to erect systems
and utilities for the efficient implementation of resource-limited
computations. High-level languages, erected on a machine-language
substrate, hide concerns about the representation of data as collections
of bits and the representation of programs as sequences of primitive
instructions. These languages have means of combination and abstraction,
such as procedure definition, that are appropriate to the larger-scale
organization of systems.</p>
<p><em>Metalinguistic abstraction</em> --
establishing new languages -- plays an important role in all branches
of engineering design. It is particularly important to computer
programming, because in programming not only can we formulate new
languages but we can also implement these languages by constructing
evaluators. An <em>evaluator</em> (or <em>interpreter</em>) for a
programming language is a procedure that, when applied to an expression
of the language, performs the actions required to evaluate that
expression.</p>
<p>It is no exaggeration to regard this as the most fundamental idea in
programming:</p>
<blockquote>
<p>The evaluator, which determines the meaning of expressions in a
programming language, is just another program.</p>
</blockquote>
<p>To appreciate this point is to change our images of ourselves as
programmers. We come to see ourselves as designers of languages, rather
than only users of languages designed by others.</p>
<p>In fact, we can regard almost any program as the evaluator for some
language. For instance, the polynomial manipulation system of
section <a href="book-Z-H-18.html#%_sec_2.5.3">2.5.3</a> embodies the rules of
polynomial arithmetic and implements them in terms of operations on
list-structured data. If we augment this system with procedures to read
and print polynomial expressions, we have the core of a special-purpose
language for dealing with problems in symbolic mathematics. The
digital-logic simulator of section <a href="book-Z-H-22.html#%_sec_3.3.4">3.3.4</a>
and the constraint propagator of
section <a href="book-Z-H-22.html#%_sec_3.3.5">3.3.5</a> are legitimate languages
in their own right, each with its own primitives, means of combination,
and means of abstraction. Seen from this perspective, the technology for
coping with large-scale computer systems merges with the technology for
building new computer languages, and computer science
itself becomes no more (and no less) than the discipline of constructing
appropriate descriptive languages.</p>
<p>We now embark on a tour of the technology by which languages are
established in terms of other languages. In this chapter we shall use
Lisp as a base, implementing evaluators as Lisp procedures.
Lisp is particularly well suited to this task, because of
its ability to represent and manipulate symbolic expressions. We will
take the first step in understanding how languages are implemented by
building an evaluator for Lisp itself. The language implemented by our
evaluator will be a subset of the Scheme dialect of Lisp that we use in
this book. Although the evaluator described in this chapter is written
for a particular dialect of Lisp, it contains the essential structure of
an evaluator for any expression-oriented language designed for writing
programs for a sequential machine. (In fact, most language processors
contain, deep within them, a little ``Lisp'' evaluator.) The
evaluator has been simplified for the purposes of illustration and
discussion, and some features have been left out that would be important
to include in a production-quality Lisp system. Nevertheless, this
simple evaluator is adequate to execute most of the programs in this
book.<a href="book-Z-H-25.html#footnote_Temp_509">^[2]{.small}^</a>{#call_footnote_Temp_509}</p>
<p>An important advantage of making the evaluator accessible as a Lisp
program is that we can implement alternative evaluation rules by
describing these as modifications to the evaluator program. One place
where we can use this power to good effect is to gain extra control over
the ways in which computational models embody the notion of time, which
was so central to the discussion in chapter 3. There, we mitigated some
of the complexities of state and assignment by using streams to decouple
the representation of time in the world from time in the computer. Our
stream programs, however, were sometimes cumbersome, because they were
constrained by the applicative-order evaluation of Scheme. In
section <a href="book-Z-H-27.html#%_sec_4.2">4.2</a>, we'll change the underlying
language to provide for a more elegant approach, by modifying the
evaluator to provide for <em>normal-order evaluation</em>.</p>
<p>Section <a href="book-Z-H-28.html#%_sec_4.3">4.3</a> implements a more ambitious
linguistic change, whereby expressions have many values, rather than
just a single value. In this language of <em>nondeterministic computing</em>,
it is natural to express processes that generate all possible values for
expressions and then search for those values that satisfy certain
constraints. In terms of models of computation and time, this is like
having time branch into a set of ``possible futures'' and then
searching for appropriate time lines. With our nondeterministic
evaluator, keeping track of multiple values and performing searches are
handled automatically by the underlying mechanism of the language.</p>
<p>In section <a href="book-Z-H-29.html#%_sec_4.4">4.4</a> we implement a
<em>logic-programming</em> language in which knowledge is expressed in terms of
relations, rather than in terms of computations with inputs and outputs.
Even though this makes the language drastically different from Lisp, or
indeed from any conventional language, we will see that the
logic-programming evaluator shares the essential structure of the Lisp
evaluator.</p>
<p>::: smallprint</p>
<hr />
<p>:::</p>
<p>::: footnote
<a href="book-Z-H-25.html#call_footnote_Temp_508">^[1]{.small}^</a>{#footnote_Temp_508}
The same idea is pervasive throughout all of engineering. For example,
electrical engineers use many different languages for describing
circuits. Two of these are the language of electrical <em>networks</em> and the
language of electrical <em>systems</em>. The network language emphasizes the
physical modeling of devices in terms of discrete electrical elements.
The primitive objects of the network language are primitive electrical
components such as resistors, capacitors, inductors, and transistors,
which are characterized in terms of physical variables called voltage
and current. When describing circuits in the network language, the
engineer is concerned with the physical characteristics of a design. In
contrast, the primitive objects of the system language are
signal-processing modules such as filters and amplifiers. Only the
functional behavior of the modules is relevant, and signals are
manipulated without concern for their physical realization as voltages
and currents. The system language is erected on the network language, in
the sense that the elements of signal-processing systems are constructed
from electrical networks. Here, however, the concerns are with the
large-scale organization of electrical devices to solve a given
application problem; the physical feasibility of the parts is assumed.
This layered collection of languages is another example of the
stratified design technique illustrated by the picture language of
section <a href="book-Z-H-15.html#%_sec_2.2.4">2.2.4</a>.</p>
<p><a href="book-Z-H-25.html#call_footnote_Temp_509">^[2]{.small}^</a>{#footnote_Temp_509}
The most important features that our evaluator leaves out are mechanisms
for handling errors and supporting debugging. For a more extensive
discussion of evaluators, see
Friedman, Wand, and Haynes
1992, which gives an exposition of programming languages that proceeds
via a sequence of evaluators written in Scheme.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="3.5.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="4.1.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="3.5.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="4.1.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="./highlight.js"></script>
        <script src="./src/languages/scheme.min.js"></script>
        <script src="./biwascheme.min.js"></script>
        <script src="./biwascheme_run_logic.js"></script>


    </div>
    </body>
</html>
